#!/usr/bin/env python3
"""
Description: Lists Windows processes similarly to ps -ef

Author: Andy Roper <andyroper42@gmail.com>
URL: https://github.com/andy-roper/roperdot
"""

import subprocess
import csv
import sys
from datetime import datetime

def format_memory(mem_str):
    """Clean up memory usage string"""
    # Remove quotes and commas, keep the K suffix
    return mem_str.replace(',', '').replace('"', '')

def help():
    print('''
pswin: Lists Windows processes similarly to ps -ef
Usages: pswin
        pswin <process-name-filter>
'''[1:-1])
    sys.exit(0)

# Check for help - need at least 2 args to access sys.argv[1]
if len(sys.argv) > 1 and sys.argv[1] in ['--help', '-?', '-h']:
    help()

# Get filter argument if provided
process_filter = sys.argv[1] if len(sys.argv) > 1 else None

# Print header - including memory usage
print(f"{'USER':<12} {'PID':>8} {'STIME':<8} {'MEM':>10} {'CMD'}")

try:
    result = subprocess.run(['tasklist.exe', '/fo', 'csv'], 
                          capture_output=True, text=True, check=True)
    
    current_time = datetime.now().strftime('%H:%M')
    
    reader = csv.reader(result.stdout.splitlines())
    next(reader)  # Skip header
    
    for row in reader:
        if len(row) >= 5:
            image_name = row[0]
            pid = int(row[1])
            mem_usage = format_memory(row[4])  # Memory Usage is 5th column (index 4)
            
            # Filter if requested
            if process_filter and process_filter.lower() not in image_name.lower():
                continue
            
            # Simple user classification
            if pid < 500:
                user = "SYSTEM"
            elif pid < 1000:
                user = "SERVICE"
            else:
                user = "user"
            
            # Show meaningful columns including memory
            print(f"{user:<12} {pid:>8} {current_time:<8} {mem_usage:>10} {image_name}")
            
except subprocess.CalledProcessError as e:
    print(f"Error running tasklist: {e}", file=sys.stderr)
    sys.exit(1)