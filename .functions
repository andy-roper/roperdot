#
# Description: Cross-platform and bash/zsh functions for roperdot dotfiles
#
# Author: Andy Roper <andyroper42@gmail.com>
# URL: https://github.com/andy-roper/roperdot
#

source "${ROPERDOT_DIR}/source-scripts/re-match"

# Characters to escape: `~!#$^&()[]{}\|'"<>? and space
escape-arg() {
	echo $(sed -E 's/([][`~!#$^&\(\)\{\}\|'\''\"<>?\\ ])/\\\1/g'<<<"$1")
}

unset-dot-glob() {
	if [[ "$ROPERDOT_CURRENT_SHELL" = bash ]]; then
		shopt -u dotglob
	else
		unsetopt globdots
	fi
}

if [[ "$ROPERDOT_CUSTOM_CD" = true ]]; then
	if [[ "$ROPERDOT_CURRENT_SHELL" = zsh ]]; then
		compdef __cd=cd
		compdef cd=cd
	fi
	__cd() {
		if [[ "$1" == "--help" || "$1" == "-h" || "$1" == "-?" ]]; then
			cat <<EOT
cd: change to a directory
Usage: cd [target]

If fzf is installed:
* If no target is given or if the target is ".", cd will prompt the user to
  select a subdirectory of the current directory to change to.
* If the target is a pattern, cd will prompt the user to select a matching
  directory. If only one directory matches, cd will change to that directory.

If the target is an archive, it will be expanded to a temporary directory and
cd will change to that directory.

If you're on MacOS and you cd to a dmg file, the dmg will be mounted and cd
will change to the mount directory.

If you're on Ubuntu or Mint and you cd to an iso file, the file will be
mounted.

If cd is called by another function or if data is piped to it, then it will
execute cd without any custom behavior.
EOT
			return
		fi
		# Turn globbing back on
		[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && set +f || set +F

		# Avoid issues when cd is called by another function, such as command completion via fzf
		if [[ ! -t 1 ||
		( "$ROPERDOT_CURRENT_SHELL" = "bash" && ${#FUNCNAME[@]} -gt 1 ) ||
		( "$ROPERDOT_CURRENT_SHELL" = "zsh" && $#funcstack -ne 1 ) ]]; then
			local arg arg_str
			for arg in "$@"; do
				arg="$(escape-arg "$arg")"
				arg_str+=" $arg"
			done
			eval "\cd $arg_str"
			return $?
		fi

		local p dir pattern
		if command -v fzf >/dev/null 2>&1; then
			if [[ $# -eq 0 || "$1" = . ]]; then
				dir=.
				pattern=*
			elif [[ "$1" =~ [*] ]]; then
				if [[ "$1" =~ / ]]; then
					dir="${1%/*}/"
					pattern="${1##*/}"
				else
					dir=.
					pattern="$1"
				fi
			fi
			if [[ -n "$dir" ]]; then
				p="$(find -L "$dir" -maxdepth 1 -type d ! -path . -iname "$pattern" -printf '%f\n' | sort)"
				if [[ -z "$p" ]]; then
					echo "No matching directories"
				elif [[ "$(wc -l<<<$p)" -eq 1 ]]; then
					if [[ -d "$dir/$p" ]]; then
						\cd "$dir/$p"
					else
						echo "cd: no such file or directory: $dir/$p"
						return 1
					fi
				else
					p="$(fzf -0 --no-sort --height 33% --layout=reverse<<<"$p")"
					if [[ -n "$p" ]]; then
						if [[ -d "$dir/$p" ]]; then
							\cd "$dir/$p"
						else
							echo "cd: no such file or directory: $dir/$p"
							return 1
						fi
					fi
				fi
				return
			fi
		fi
		p="$(abs-path "$1")"
		if [[ -n "$(is-archive "$p")" ]]; then
			destdir=$(mktemp -d)
			pushd "$destdir" || return 1
			extract-archive "$p"
		elif [[ "$ROPERDOT_OS_ENV" = "darwin" && "$1" =~ \.dmg$ ]]; then
			mount_dir="$(mount-dmg "$p")"
			if [[ -n "$mount_dir" ]]; then
				cd "$mount_dir" || return 1
				echo "When you're done using the dmg, unmount it like: hdiutil detach \"$mount_dir\""
			fi
		elif [[ "$ROPERDOT_OS_ENV" = "ubuntu" || "$ROPERDOT_OS_ENV" = "mint" ]] && [[ "$1" =~ \.iso$ ]]; then
			mount-iso-readonly "$p"
		else
			if [[ -d "$p" ]]; then
				cd "$p"
			else
				echo "cd: no such file or directory: $p"
				return 1
			fi
		fi
	}
fi

if [[ "$ROPERDOT_CUSTOM_LS" = true ]]; then
	if [[ "$ROPERDOT_CURRENT_SHELL" = zsh ]]; then
		compdef __ls=ls
		compdef ls=ls
	fi
	# Apply color switch in LS_SWITCHES to all ls commands unless output is being piped
	# Show the contents of a symlink directory argument instead of the symlink itself
	# Use the -d switch for non-directory arguments to suppress single-level recursion into directories
	# Match hidden files with *
	__ls() {
		# Determine which ls command to use
		local LS_CMD
		if [[ "$ROPERDOT_OS_ENV" = "darwin" ]] && command -v gls >/dev/null 2>&1; then
			LS_CMD="gls"
		else
			LS_CMD='\ls'
		fi
		
		# Turn globbing back on
		[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && set +f || set +F
		local arg arg_str
		# If ls is called by a function or script or via a pipe, execute it without customization
		if [[ ! -t 1 ||
		( "$ROPERDOT_CURRENT_SHELL" = "bash" && ${#FUNCNAME[@]} -gt 1 ) ||
		( "$ROPERDOT_CURRENT_SHELL" = "zsh" && $#funcstack -ne 1 ) ]]; then
			for arg in "$@"; do
				arg="$(escape-arg "$arg")"
				arg_str+=" $arg"
			done
			eval "$LS_CMD $arg_str"
			return $?
		fi
		local d switches=()
		while [[ "$1" =~ ^- ]]; do
			[[ "$1" == "--" ]] && shift && break
			switches+=("$1")
			shift
		done
		[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && shopt -s dotglob || setopt glob_dots
		if [[ $# -eq 0 ]]; then
			eval "$LS_CMD $LS_SWITCHES ${switches[@]}"
		else
			local re="\.\.\."
			for arg in "$@"; do
				while [[ "$arg" =~ $re ]]; do
					arg="${arg//.../../..}"
				done
				if [[ -d "$arg" ]]; then
					[[ -L "$arg" ]] && arg+="/"
				else
					[[ "$arg" != "." ]] && switches+=("-d")
				fi
#				local arg_escaped="${arg// /\\ }"
#				arg_escaped="${arg_escaped//'/\\'}"
				local arg_escaped="$(escape-arg "$arg")"
	            eval $LS_CMD $LS_SWITCHES ${switches[@]} "$arg_escaped"
			done
		fi
		[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && shopt -u dotglob || setopt no_glob_dots
	}
else
    __ls() {
        ls "$@"
    }
fi

if [[ "$ROPERDOT_CUSTOM_CP" = true ]]; then
	if [[ "$ROPERDOT_CURRENT_SHELL" = zsh ]]; then
		compdef __cp=cp
		compdef cp=cp
	fi
	__cp() {
		# Turn globbing back on
		[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && set +f || set +F

		local arg arg_str
		if [[ ! -t 1 ||
		( "$ROPERDOT_CURRENT_SHELL" = "bash" && ${#FUNCNAME[@]} -gt 1 ) ||
		( "$ROPERDOT_CURRENT_SHELL" = "zsh" && $#funcstack -ne 1 ) ]]; then
			for arg in "$@"; do
				arg="$(escape-arg "$arg")"
				arg_str+=" $arg"
			done
			eval "\cp $arg_str"
			return $?
		fi

		local switches=() use_cwd
		while [[ "$1" =~ ^- ]]; do
			switches+=("$1")
			[[ "$1" == "--" ]] && shift && break
			shift
		done
		# Use cwd as target if:
		# if only have one argument, use_cwd=true
		# if last argument is not a directory and have 2 arguments:
		#    2nd arg is pattern => use_cwd=true
		#    2nd arg is file and 1st arg is not file => use_cwd=true
		local re="\.\.\."
		if [[ $# -eq 1 ]]; then
			use_cwd=true
		else
			local last_arg arg_count=$#
			if [[ "$ROPERDOT_CURRENT_SHELL" = bash ]]; then
				last_arg="${!arg_count}"
			else
				last_arg="$argv[$arg_count]"
			fi
			while [[ "$last_arg" =~ $re ]]; do
				last_arg="${last_arg//.../../..}"
			done
			if [[ ! -d "$last_arg" && $arg_count -eq 2 ]]; then
				[[ "$last_arg" =~ [*] || "$1" =~ [*] || -d "$1" ]] && use_cwd=true
			fi
		fi
		for arg in "$@"; do
			while [[ "$arg" =~ $re ]]; do
				arg="${arg//.../../..}"
			done
			arg="$(escape-arg "$arg")"
			arg_str+=" $arg"
		done
		if [[ "$ROPERDOT_CURRENT_SHELL" = bash ]]; then
			shopt -s dotglob
		else
			setopt globdots
		fi
		trap unset-dot-glob EXIT
		if [[ -n "$use_cwd" ]]; then
			eval "\cp ${switches[@]} -- $arg_str ."
		else
			eval "\cp ${switches[@]} -- $arg_str"
		fi
	}
fi

if [[ "$ROPERDOT_CUSTOM_MV" = true ]]; then
	if [[ "$ROPERDOT_CURRENT_SHELL" = zsh ]]; then
		compdef __mv=mv
		compdef mv=mv
	fi
	__mv() {
		# Turn globbing back on
		[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && set +f || set +F

		local arg arg_str
		if [[ ! -t 1 ||
		( "$ROPERDOT_CURRENT_SHELL" = "bash" && ${#FUNCNAME[@]} -gt 1 ) ||
		( "$ROPERDOT_CURRENT_SHELL" = "zsh" && $#funcstack -ne 1 ) ]]; then
			for arg in "$@"; do
				arg="$(escape-arg "$arg")"
				arg_str+=" $arg"
			done
			eval "\mv $arg_str"
			return $?
		fi

		local switches=() use_cwd
		while [[ "$1" =~ ^- ]]; do
			switches+=("$1")
			[[ "$1" == "--" ]] && shift && break
			shift
		done
		local re="\.\.\."
		if [[ $# -eq 1 ]]; then
			use_cwd=true
		else
			local last_arg arg_count=$#
			if [[ "$ROPERDOT_CURRENT_SHELL" = bash ]]; then
				last_arg="${!arg_count}"
			else
				last_arg="$argv[$arg_count]"
			fi
			while [[ "$last_arg" =~ $re ]]; do
				last_arg="${last_arg//.../../..}"
			done
			if [[ ! -d "$last_arg" && $arg_count -eq 2 ]]; then
				[[ "$last_arg" =~ [*] || "$1" =~ [*] ]] && use_cwd=true
			fi
		fi
		for arg in "$@"; do
			while [[ "$arg" =~ $re ]]; do
				arg="${arg//.../../..}"
			done
			arg="$(escape-arg "$arg")"
			arg_str+=" $arg"
		done
		if [[ "$ROPERDOT_CURRENT_SHELL" = bash ]]; then
			shopt -s dotglob
		else
			setopt globdots
		fi
		trap unset-dot-glob EXIT
		if [[ -n "$use_cwd" ]]; then
			eval "\mv ${switches[@]} -- $arg_str ."
		else
			eval "\mv ${switches[@]} -- $arg_str"
		fi
	}
fi

if [[ "$ROPERDOT_CUSTOM_RM" = true ]]; then
	if [[ "$ROPERDOT_CURRENT_SHELL" = zsh ]]; then
		compdef __rm=rm
		compdef rm=rm
	fi
	__rm() {
		# Turn globbing back on
		[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && set +f || set +F

		local arg arg_str
		if [[ ! -t 1 ||
		( "$ROPERDOT_CURRENT_SHELL" = bash && ${#FUNCNAME[@]} -gt 1 ) ||
		( "$ROPERDOT_CURRENT_SHELL" = zsh && $#funcstack -ne 1 ) ]]; then
			for arg in "$@"; do
				arg="$(escape-arg "$arg")"
				arg_str+=" $arg"
			done
			eval "\rm $arg_str"
			return $?
		fi

		local switches=() re="\.\.\."
		while [[ "$1" =~ ^- ]]; do
			switches+=("$1")
			[[ "$1" == "--" ]] && shift && break
			shift
		done
		for arg in "$@"; do
			while [[ "$arg" =~ $re ]]; do
				arg="${arg//.../../..}"
			done
			arg="$(escape-arg "$arg")"
			arg_str+=" $arg"
		done
		if [[ "$ROPERDOT_CURRENT_SHELL" = bash ]]; then
			shopt -s dotglob
		else
			setopt globdots
		fi
		trap unset-dot-glob EXIT
		eval "\rm ${switches[@]} -- $arg_str"
	}
fi

cdd() {
	if [[ "$1" == "--help" || "$1" == "-h" || "$1" == "-?" ]] ; then
		[[ "$ROPERDOT_CURRENT_SHELL" = zsh ]] && compdef cdd=cd
		cat <<EOT
cdd: cd to subdirectory of the current directory or a target directory
Usage: cdd [target-dir]

cdd will use fzf to allow you to choose a directory to cd to which is a child
directory of the target directory, or of the current directory if no target
is specified.
EOT
		return
	fi
	local dir
	if [[ $# -eq 0 ]]; then
		dir="$(fd --max-depth 1 --type d | fzf --height 40% --layout=reverse)"
	else
		dir="$(fd --max-depth 1 --type d . "$1" | fzf --height 40% --layout=reverse)"
	fi
	if [[ -n "$dir" ]]; then
		\cd "$dir" || return 1
	fi
}

cds() {
	if [[ "$1" == "--help" || "$1" == "-h" || "$1" == "-?" ]] ; then
		cat <<EOT
cds: cd to deep subdirectory under the current directory or a target directory
Usage: cds [target-dir]

cds will use fzf to allow you to choose a directory to cd to which is a deep
child directory of the target directory, or of the current directory if no
target is specified.
EOT
		return
	fi
	local dir
	if [[ $# -eq 0 ]]; then
		dir="$(fd --type d | fzf --height 40% --layout=reverse)"
	else
		dir="$(fd --type d . "$1" | fzf --height 40% --layout=reverse)"
	fi
	if [[ -n "$dir" ]]; then
		\cd "$dir" || return 1
	fi
}

lsd() {
	if [[ -n "$1" ]]; then
		ls "$1" | grep "^d"
	else
		ls | grep "^d"
	fi
}

# List all files, long format, colorized, permissions in octal
function la() {
	if [[ "$ROPERDOT_OS_ENV" = "darwin" ]] && command -v gls >/dev/null 2>&1; then
		# Use gls (GNU ls) - gets ISO date format
		__ls -l --group-directories-first --time-style=long-iso "$@" | awk '
		{
		   k = 0;
		   for (i = 0; i <= 8; i++)
		      k += ((substr($1, i + 2, 1)~/[rwx]/) * 2^(8 - i));
		   if (k)
		      printf("%0o ", k);
		   printf(" %9s  %10s %5s  %6s  %s %s %s\n", $3, $6, $7, $5, $8, $9, $10);
		}'
	elif [[ "$ROPERDOT_OS_ENV" = "darwin" ]]; then
		# BSD ls - gets separate month/day/year fields, __ls will filter GNU flags
		__ls -l --group-directories-first --time-style=long-iso "$@" | awk '
		{
		   k = 0;
		   for (i = 0; i <= 8; i++)
		      k += ((substr($1, i + 2, 1)~/[rwx]/) * 2^(8 - i));
		   if (k)
		      printf("%0o ", k);
		   printf(" %9s  %3s %2s %5s  %6s  %s %s %s\n", $3, $6, $7, $8, $5, $9, $10, $11);
		}'
	else
		# Linux/other - assume GNU ls with ISO date format  
		__ls -l --group-directories-first --time-style=long-iso "$@" | awk '
		{
		   k = 0;
		   for (i = 0; i <= 8; i++)
		      k += ((substr($1, i + 2, 1)~/[rwx]/) * 2^(8 - i));
		   if (k)
		      printf("%0o ", k);
		   printf(" %9s  %10s %5s  %6s  %s %s %s\n", $3, $6, $7, $5, $8, $9, $10);
		}'
	fi
}

lh() {
    __ls -la --color=always --time-style=long-iso --group-directories-first "$@" | awk '
    BEGIN {
        OFS = " "
    }
    NR == 1 {
        if ($1 == "total") {
            total_kb = $2
            total_bytes = total_kb * 1024
            
            if (total_bytes >= 1073741824) {
                # GB range -> show in MB
                printf "total %.0fM\n", total_bytes/1048576
            } else if (total_bytes >= 1048576 || total_bytes >= 100000) {
                # MB range OR bytes that would be 6+ digits -> show in KB
                printf "total %.0fK\n", total_bytes/1024
            } else {
                # Smaller totals -> show in bytes (≤5 digits)
                printf "total %dB\n", total_bytes
            }
        } else {
            print
        }
        next
    }
    {
        # Convert size to human readable (shift down one unit level, max 5 digits)
        size = $5
        if (size >= 1073741824) {
            # GB range -> show in MB
            human = sprintf("%.0fM", size/1048576)
        } else if (size >= 1048576 || size >= 100000) {
            # MB range OR bytes that would be 6+ digits -> show in KB
            human = sprintf("%.0fK", size/1024)
        } else {
            # Smaller files -> show in bytes (≤5 digits)
            human = sprintf("%dB", size)
        }
        
        # Print with proper column alignment
        printf "%-11s %2s %-8s %-8s %8s %s %s", $1, $2, $3, $4, human, $6, $7
        
        # Handle filename and any remaining fields (like symlink targets)
        for(i=8; i<=NF; i++) {
            printf " %s", $i
        }
        printf "\n"
    }'
}

if [[ $ROPERDOT_CURRENT_SHELL = bash ]]; then
	dir_stack_chevrons() {
		local chevron_str dirs_count
		dirs_count=$(dirs -p | wc -l)
		for (( i = 1; i < $dirs_count; i++ )) {
			chevron_str+=">"
		}
		echo $chevron_str
	}
fi

pushd() {
	local path="$(abs-path "$1")"
	if [[ -d "$path" ]]; then
		builtin pushd "$path" >/dev/null || return 1
	else
		echo -bash: pushd: "$path": No such file or directory
	fi
}

popd() {
	builtin popd >/dev/null || return 1
}

# mdd: create a directory and cd to it
mdd() {
	if [[ "$1" == "--help" || "$1" == "-h" || "$1" == "-?" ]] ; then
		cat <<EOT
mdd: create a directory and then cd into it
Usage: mdd <directory>
EOT
		return
	fi
	if mkdir -p "$1"; then
		cd "$1" || return 1
	fi
}

_dot() {
	if [[ $# -eq 0 ]] ; then
		cd ~ || return 1
	else
		source "$@"
	fi
}

[[ "$ROPERDOT_CURRENT_SHELL" = zsh ]] && compdef _dot=source

# Fix usage of EDITOR by crontab
if command -v crontab >/dev/null 2>&1; then
	crontab() { EDITOR=vi command crontab "$@"; }
fi

# Use alternative backup directory for vi and nvim if the user doesn't have write authority
# for the directory the file to be edited is in

if type vi 2>/dev/null | grep alias >/dev/null; then
	unalias vi
fi

vi() {
	if [[ -n $ROPERDOT_VI_BIN ]]; then
		if [[ -n "$1" ]]; then
			if [[ -w "$(dirname "$1"))" ]]; then
				$ROPERDOT_VI_BIN "$1"
			else
				[[ -d ~/.vim/backup ]] || mkdir -p ~/.vim/backup
				$ROPERDOT_VI_BIN -c "set backupdir=~/.vim/backup" "$1"
			fi
		elif [[ -w "$(pwd)" ]]; then
			$ROPERDOT_VI_BIN
		else
			[[ -d ~/.vim/backup ]] || mkdir -p ~/.vim/backup
			$ROPERDOT_VI_BIN -c "set backupdir=~/.vim/backup"
		fi
	else
		command vi "$@"
	fi
}

if command -v nvim >/dev/null 2>&1; then
	nvim() {
		if [[ -n "$1" ]]; then
			if [[ -w "$(dirname "$1"))" ]]; then
				command nvim "$1"
			else
				[[ -d ~/.vim/backup ]] || mkdir -p ~/.vim/backup
				command nvim -c "set backupdir=~/.vim/backup" "$1"
			fi
		elif [[ -w "$(pwd)" ]]; then
			command nvim
		else
			[[ -d ~/.vim/backup ]] || mkdir -p ~/.vim/backup
			command nvim -c "set backupdir=~/.vim/backup"
		fi
	}
fi

if [[ "$ROPERDOT_CURRENT_SHELL" = bash ]]; then
	if command -v perl >/dev/null 2>&1; then
		# setnf: shows output of set with contents of functions suppressed
		setnf() {
			if [[ "$1" == "--help" || "$1" == "-h" || "$1" == "-?" ]] ; then
				cat <<EOT
setnf: print trimmed environment variable and function values
Usage: setnf

This will show the environment variables and functions that are defined but
will suppress display of the contents of functions for more compact output.
EOT
				return
			fi
			set | process-setnf
		}

	fi
else
	setnf() {
		set
		print -f "%s()\n" "${(ok)functions}"
	}
fi

if command -v fd >/dev/null 2>&1; then
	if ! command -v fdfind >/dev/null 2>&1; then
		fdfind() { fd "$@"; }
	fi

	# _ff: finds files matching a pattern
	# called by ff alias
	_ff() {
		if [[ $# -eq 0 || "$1" == "--help" || "$1" == "-h" || "$1" == "-?" ]]; then
			cat <<EOT
ff: find files whose names match a pattern
Usage: ff [options] <pattern> [directory]

This will print a list of all files that match a pattern within the directory
and its subdirectories. Asterisks don't have to be quoted; filename expansion
is suppressed by the alias that calls this function.

To include files which are ignored by default (e.g. .gitignore, .ignore, .env),
use the -I option.

ff uses fd to perform file searches and uses its options. See the fd man page
for more information.
EOT
			return
		fi
		local searchpath pattern switches=()
		while [[ "$1" =~ ^- ]]; do
			switches+=("$1")
			[[ "$1" == "--" ]] && shift && break
			shift
		done
		re="^(.*)/([^/]*)$"
		if re_match "$1" "$re"; then
			searchpath="${re_match[1]}"
			pattern="${re_match[2]}"
		elif [[ -z "$2" ]]; then
			searchpath=$(pwd)
			pattern="$1"
		else
			pattern="$1"
			searchpath="$2"
		fi

		fd -gH --no-ignore-vcs ${switches[@]} "$pattern" "$searchpath"
	}

	_fsz() {
		if [[ "$1" == "--help" || "$1" == "-?" ]] ; then
			cat <<EOT
fsz: find files whose names match a pattern and print size information
Usage: fsz [-h] [-r] [-t] <pattern> [directory]

This will print sizes and filenames for all files that match a pattern within
the directory. Asterisks don't have to be quoted; filename expansion is
suppressed by the alias that calls this function.

Options:
-h, --human       Print human-readable sizes
-r, --recurse     Search recursively
-t, --total-only  Only print the total

fsz uses fdfind to perform file searches.
EOT
			return
		fi
		while :; do
			case "$1" in
				-h|--human)   local human_readable=true; shift ;;
				-r|--recurse) local recursing=true; shift ;;
				-t|--total)   local total_only=true; shift ;;
				*) break ;;
			esac
		done
		local re="^(.*)/([^/]*)$"
		if re_match "$1" "$re"; then
			local searchpath="${re_match[1]}"
			local pattern="${re_match[2]}"
		elif [[ -z "$2" ]]; then
			local searchpath=.
			local pattern="$1"
		else
			pattern="$1"
			searchpath="$2"
		fi
		[[ -z $pattern ]] && pattern="*"
		if [[ -n $total_only ]]; then
			if [[ -n $recursing ]]; then
				if [[ -n $human_readable ]]; then
					fdfind --no-ignore-vcs -gH "$pattern" "$searchpath" -X du -b | awk '
					function human(x) {
					    if (x<1000) {return x} else {x/=1024}
					    s="KMGTEPZY";
					    while (x>=1000 && length(s)>1)
					        {x/=1024; s=substr(s,2)}
					    return int(x+0.5) substr(s,1,1)
					}
					{ total += $1 }; END { print human(total) }'
				else
					fdfind --no-ignore-vcs -gH "$pattern" "$searchpath" -X du -b | awk '{ total += $1 }; END { printf "%'\''d\n", total }'
				fi
			else
				if [[ -n $human_readable ]]; then
					fdfind --no-ignore-vcs -d 1 -t f -gH "$pattern" "$searchpath" -X du -b | awk '
					function human(x) {
					    if (x<1000) {return x} else {x/=1024}
					    s="KMGTEPZY";
					    while (x>=1000 && length(s)>1)
					        {x/=1024; s=substr(s,2)}
					    return int(x+0.5) substr(s,1,1)
					}
					{ total += $1 }; END { print human(total) }'
				else
					fdfind --no-ignore-vcs -d 1 -t f -gH "$pattern" "$searchpath" -X du -b | awk '{ total += $1 }; END { printf "%'\''d\n", total }'
				fi
			fi
		else
			if [[ -n $recursing ]]; then
				if [[ -n $human_readable ]]; then
					fdfind --no-ignore-vcs -gH "$pattern" "$searchpath" -X du -b | awk '
					function human(x) {
					    if (x<1000) {return x} else {x/=1024}
					    s="KMGTEPZY";
					    while (x>=1000 && length(s)>1)
					        {x/=1024; s=substr(s,2)}
					    return int(x+0.5) substr(s,1,1)
					}
					{ total += $1; printf "%s\t", human($1); for(i=2;i<=NF;i++) printf $i" "; print "" }; END { print human(total) }'
				else
					fdfind --no-ignore-vcs -gH "$pattern" "$searchpath" -X du -b | awk '{ total += $1; printf "%'\''d\t", $1; for(i=2;i<=NF;i++) printf $i" "; print "" }; END { printf "%'\''d\n", total }'
				fi
			else
				if [[ -n $human_readable ]]; then
					fdfind --no-ignore-vcs -d 1 -t f -gH "$pattern" "$searchpath" -X du -b | awk '
					function human(x) {
					    if (x<1000) {return x} else {x/=1024}
					    s="KMGTEPZY";
					    while (x>=1000 && length(s)>1)
					        {x/=1024; s=substr(s,2)}
					    return int(x+0.5) substr(s,1,1)
					}
					{ total += $1; printf "%s\t", human($1); for(i=2;i<=NF;i++) printf $i" "; print "" }; END { print human(total) }'
				else
					fdfind --no-ignore-vcs -d 1 -t f -gH "$pattern" "$searchpath" -X du -b | awk '{ total += $1; printf "%'\''d\t", $1; for(i=2;i<=NF;i++) printf $i" "; print "" }; END { printf "%'\''d\n", total }'
				fi
			fi
		fi
	}

else  # fd is not installed

	# _ff: finds files matching a pattern
	# called by ff alias
	_ff() {
		if [[ $# -eq 0 || "$1" == "--help" || "$1" == "-h" || "$1" == "-?" ]] ; then
			cat <<EOT
ff: find files whose names match a pattern
Usage: ff <pattern> [directory]

This will print a list of all files that match a pattern within the a directory
and its subdirectories. Asterisks don't have to be quoted; filename expansion
is suppressed by the alias that calls this function.
EOT
			return
		fi
		local searchpath pattern
		re="^(.*)/([^/]*)$"
		if re_match "$1" "$re"; then
			searchpath="${re_match[1]}"
			pattern="${re_match[2]}"
		elif [[ -z "$2" ]]; then
			searchpath=$(pwd)
			pattern="$1"
		else
			pattern="$1"
			searchpath="$2"
		fi
		find "$searchpath" -iname "$pattern" 2>/dev/null
	}

	_fsz() {
		if [[ "$1" == "--help" || "$1" == "-?" ]] ; then
			cat <<EOT
fsz: find files whose names match a pattern and print size information
Usage: fsz [-h] [-r] [-t] <pattern> [directory]

This will print sizes and filenames for all files that match a pattern within
the directory. Asterisks don't have to be quoted; filename expansion is
suppressed by the alias that calls this function.

Options:
-h, --human       Print human-readable sizes
-r, --recurse     Search recursively
-t, --total-only  Only print the total
EOT
			return
		fi
		while :; do
			case "$1" in
				-h|--human)   local human_readable=true; shift ;;
				-r|--recurse) local recursing=true; shift ;;
				-t|--total)   local total_only=true; shift ;;
				*) break ;;
			esac
		done
		local re="^(.*)/([^/]*)$"
		if re_match "$1" "$re"; then
			local searchpath="${re_match[1]}"
			local pattern="${re_match[2]}"
		elif [[ -z "$2" ]]; then
			local searchpath=.
			local pattern="$1"
		else
			pattern="$1"
			searchpath="$2"
		fi
		[[ -z $pattern ]] && pattern="*"
		if [[ -n $total_only ]]; then
			if [[ -n $recursing ]]; then
				if [[ -n $human_readable ]]; then
					find "$searchpath" -iname "$pattern" -print0 | xargs -0 du -b | awk '
					function human(x) {
					    if (x<1000) {return x} else {x/=1024}
					    s="KMGTEPZY";
					    while (x>=1000 && length(s)>1)
					        {x/=1024; s=substr(s,2)}
					    return int(x+0.5) substr(s,1,1)
					}
					{ total += $1 }; END { print human(total) }'
				else
					find "$searchpath" -iname "$pattern" -print0 | xargs -0 du -b | awk '{ total += $1 }; END { printf "%'\''d\n", total }'
				fi
			else
				if [[ -n $human_readable ]]; then
					find "$searchpath" -maxdepth 1 -type f -iname "$pattern" -print0 | xargs -0 du -b | awk '
					function human(x) {
					    if (x<1000) {return x} else {x/=1024}
					    s="KMGTEPZY";
					    while (x>=1000 && length(s)>1)
					        {x/=1024; s=substr(s,2)}
					    return int(x+0.5) substr(s,1,1)
					}
					{ total += $1 }; END { print human(total) }'
				else
					find "$searchpath" -maxdepth 1 -type f -iname "$pattern" -print0 | xargs -0 du -b | awk '{ total += $1 }; END { printf "%'\''d\n", total }'
				fi
			fi
		else
			if [[ -n $recursing ]]; then
				if [[ -n $human_readable ]]; then
					find "$searchpath" -iname "$pattern" -print0 | xargs -0 du -b | awk '
					function human(x) {
					    if (x<1000) {return x} else {x/=1024}
					    s="KMGTEPZY";
					    while (x>=1000 && length(s)>1)
					        {x/=1024; s=substr(s,2)}
					    return int(x+0.5) substr(s,1,1)
					}
					{ total += $1; printf "%s\t", human($1); for(i=2;i<=NF;i++) printf $i" "; print "" }; END { print human(total) }'
				else
					find "$searchpath" -iname "$pattern" -print0 | xargs -0 du -b | awk '{ total += $1; printf "%'\''d\t", $1; for(i=2;i<=NF;i++) printf $i" "; print "" }; END { printf "%'\''d\n", total }'
				fi
			else
				if [[ -n $human_readable ]]; then
					find "$searchpath" -maxdepth 1 -type f -iname "$pattern" -print0 | xargs -0 du -b | awk '
					function human(x) {
					    if (x<1000) {return x} else {x/=1024}
					    s="KMGTEPZY";
					    while (x>=1000 && length(s)>1)
					        {x/=1024; s=substr(s,2)}
					    return int(x+0.5) substr(s,1,1)
					}
					{ total += $1; printf "%s\t", human($1); for(i=2;i<=NF;i++) printf $i" "; print "" }; END { print human(total) }'
				else
					find "$searchpath" -maxdepth 1 -type f -iname "$pattern" -print0 | xargs -0 du -b | awk '{ total += $1; printf "%'\''d\t", $1; for(i=2;i<=NF;i++) printf $i" "; print "" }; END { printf "%'\''d\n", total }'
				fi
			fi
		fi
	}
fi  # fd if

if command -v ag >/dev/null 2>&1; then
	# ft: finds files in the current directory whose contents contain the specified patttern
	_ft() {
		if [[ $# -eq 0 || "$1" == "--help" || "$1" == "-h" || "$1" == "-?" ]] ; then
			cat <<EOT
ft: search files for a pattern
Usage: ft [options] <pattern> [filespec ...]

ft will do a case-insensitive text search using The Silver Searcher to print
lines in files in the current directory or a directory referenced in a filespec
that match the pattern. If no filespec is provided, all files in the current
directory will be searched. If one or more filespecs are provided, only files
matching those filespecs will be searched.

The Silver Searcher ignores files specified in .gitignore and .hgignore by default.
To enable searching usually ignored files (such as the contents of the lib
directory in a node application), either use the unrestricted switch or set the
ROPERDOT_FT_ALL environment variable.

Options
-a or --all        Search all files including ignored files
-c                 Search for pattern in a case-sensitive fashion
-e                 Exclude hidden files from being searched
-f or --filenames  Print only the filenames that match (don't print the matching
                   lines)
-s                 Sort output

Examples:
ft perl
ft perl *.pl
ft perl ~/roperdot
ft perl ~/roperdot/*.pl
EOT
			return
		fi
		# Turn globbing back on
		[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && set +f || set +F

		local type_flag filename_flag case_flag=--ignore-case sort_output
		while [[ "$1" =~ ^- ]]; do
			[[ "$1" == "--" ]] && shift && break
			[[ "$1" == "--all" ]] && type_flag=--unrestricted && shift && continue
			[[ "$1" == "--filenames" ]] && filename_flag=--files-with-matches && shift && continue
			[[ "$1" =~ [aA] ]] && type_flag=--unrestricted
			[[ "$1" =~ [cC] ]] && unset case_flag
			[[ "$1" =~ [eE] ]] && type_flag=NO_HIDDEN
			[[ "$1" =~ [fF] ]] && filename_flag=--files-with-matches
			[[ "$1" =~ [sS] ]] && sort_output=true
			shift
		done
		if [[ -z "$type_flag" ]]; then
			if [[ -n "$ROPERDOT_FT_ALL" ]]; then
				type_flag=--unrestricted
			else
				type_flag=--hidden
			fi
		elif [[ "$type_flag" = "NO_HIDDEN" ]]; then
			unset type_flag
		fi
		if [[ $# -eq 1 ]]; then
			if [[ -n "$sort_output" ]]; then
				ag --nogroup --norecurse --color $case_flag $type_flag $filename_flag "$1" | sort
			else
				ag --nogroup --norecurse $case_flag $type_flag $filename_flag "$1"
			fi
		else
			local pattern="$1"
			shift
			while [[ $# -gt 0 ]]; do
				if [[ -d "$1" ]]; then
					ag --nogroup --norecurse $case_flag $type_flag $filename_flag "$pattern" "$1"
				else
					if re_match "$1" "^(.*)/(.*?)$"; then
						local file_pattern="${re_match[2]}"
						local target_dir="${re_match[1]}"
					else
						local file_pattern="$1"
					fi
					# Replace "." with "\." and "*" with ".*"
					file_pattern="${file_pattern/\./\\.}"
					file_pattern="${file_pattern/\*/.*}"
					if [[ -n "$target_dir" ]]; then
						if [[ -n "$sort_output" ]]; then
							ag --nogroup --norecurse --color $case_flag $type_flag $filename_flag --file-search-regex "$file_pattern\$" "$pattern" "$target_dir" | sort
						else
							ag --nogroup --norecurse $case_flag $type_flag $filename_flag --file-search-regex "$file_pattern\$" "$pattern" "$target_dir"
						fi
					else
						if [[ -n "$sort_output" ]]; then
							ag --nogroup --norecurse --color $case_flag $type_flag $filename_flag --file-search-regex "$file_pattern\$" "$pattern" | sort
						else
							ag --nogroup --norecurse $case_flag $type_flag $filename_flag --file-search-regex "$file_pattern\$" "$pattern"
						fi
					fi
				fi
				shift
			done
		fi
	}

	_ftr() {
		if [[ $# -eq 0 || "$1" == "--help" || "$1" == "-h" || "$1" == "-?" ]] ; then
			cat <<EOT
ftr: recursively search files for a pattern
Usage: ftr [options] <pattern> [filespec ...]

ftr will do a recursive, case-insensitive text search using The Silver Searcher
to print lines in files in the current directory that match the pattern. If no
filespec is provided, all files in the current directory will be searched. If
one or more filespecs are provided, only files matching those filespecs will be
searched.

The Silver Searcher ignores files specified in .gitignore and .hgignore by default.
To enable searching usually ignored files (such as the contents of the lib
directory in a node application), either use the unrestricted switch or set the
ROPERDOT_FT_ALL environment variable.

Options
-a or --all        Search all files including ignored files
-c                 Search for pattern in a case-sensitive fashion
-e                 Exclude hidden files from being searched
-f or --filenames  Print only the filenames that match (don't print the matching
                   lines)
-s                 Sort output

Examples:
ftr perl
ftr perl *.pl
ftr perl ~/roperdot
ftr perl ~/roperdot/*.pl
EOT
		return
		fi

		# Turn globbing back on
		[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && set +f || set +F
		local type_flag filename_flag case_flag=--ignore-case sort_output
		while [[ "$1" =~ ^- ]]; do
			[[ "$1" == "--" ]] && shift && break
			[[ "$1" == "--all" ]] && type_flag=--unrestricted && shift && continue
			[[ "$1" == "--filenames" ]] && filename_flag=--files-with-matches && shift && continue
			[[ "$1" =~ [aA] ]] && type_flag=--unrestricted
			[[ "$1" =~ [cC] ]] && unset case_flag
			[[ "$1" =~ [eE] ]] && type_flag=NO_HIDDEN
			[[ "$1" =~ [fF] ]] && filename_flag=--files-with-matches
			[[ "$1" =~ [sS] ]] && sort_output=true
			shift
		done
		if [[ -z "$type_flag" ]]; then
			if [[ -n "$ROPERDOT_FT_ALL" ]]; then
				type_flag=--unrestricted
			else
				type_flag=--hidden
			fi
		fi
		if [[ $# -eq 1 ]]; then
			if [[ -n "$sort_output" ]]; then
				ag --nogroup --color $case_flag $type_flag $filename_flag "$1" | sort
			else
				ag --nogroup $case_flag $type_flag $filename_flag "$1"
			fi
		else
			local pattern="$1"
			shift
			while [[ $# -gt 0 ]] ; do
				if [[ -d "$1" ]]; then
					if [[ -n "$sort_output" ]]; then
						ag --nogroup --color $case_flag $type_flag $filename_flag "$pattern" "$1" | sort
					else
						ag --nogroup $case_flag $type_flag $filename_flag "$pattern" "$1"
					fi
				else
					if re_match "$1" "^(.*)/(.*?)$"; then
						local file_pattern="${re_match[2]}"
						local target_dir="${re_match[1]}"
					else
						local file_pattern="$1"
					fi
					# Replace "." with "\." and "*" with ".*"
					file_pattern="${file_pattern/\./\\.}"
					file_pattern="${file_pattern/\*/.*}"
					if [[ -n "$target_dir" ]]; then
						if [[ -n "$sort_output" ]]; then
							ag --nogroup --color $case_flag $type_flag $filename_flag --file-search-regex "$file_pattern\$" "$pattern" "$target_dir" | sort
						else
							ag --nogroup $case_flag $type_flag $filename_flag --file-search-regex "$file_pattern\$" "$pattern" "$target_dir"
						fi
					else
						if [[ -n "$sort_output" ]]; then
							ag --nogroup --color $case_flag $type_flag $filename_flag --file-search-regex "$file_pattern\$" "$pattern" | sort
						else
							ag --nogroup $case_flag $type_flag $filename_flag --file-search-regex "$file_pattern\$" "$pattern"
						fi
					fi
				fi
				shift
			done
		fi
	}
else
	# ft: finds files in the current directory whose contents contain the specified patttern
	_ft() {
		if [[ $# -eq 0 || "$1" == "--help" || "$1" == "-h" || "$1" == "-?" ]] ; then
			cat <<EOT
ft: search files for a pattern
Usage: ft [options] <pattern> [filespec ...]

ft will do a case-insensitive text search using grep to print lines in files in
the current directory or a directory referenced in a filespec that match the
pattern. If no filespec is provided, all files in the current directory will be
searched. If one or more filespecs are provided, only files matching those
filespecs will be searched.

Options
-c                 Search for pattern in a case-sensitive fashion
-f or --filenames  Print only the filenames that match (don't print the matching
                   lines)

Examples:
ft perl
ft perl *.pl
ft perl ~/roperdot
ft perl ~/roperdot/*.pl
EOT
			return
		fi

		# Turn globbing back on
		[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && set +f || set +F

		local filename_flag case_flag=-i
		while [[ "$1" =~ ^- ]]; do
			[[ "$1" == "--" ]] && shift && break
			[[ "$1" == "--filenames" ]] && filename_flag=--files-with-matches && shift && continue
			[[ "$1" =~ [fF] ]] && filename_flag=--files-with-matches
			[[ "$1" =~ [cC] ]] && case_flag=
			shift
		done

		if [[ $# -eq 1 ]] ; then
			grep $filename_flag -isFHn "$1" ./* .*
		else
			local pattern=$1
			shift
			while [[ $# -gt 0 ]]; do
				if [[ -d "$1" ]]; then
					grep $filename_flag $case_flag -FHn -d skip "$pattern" "$1"/*
				else
					grep $filename_flag $case_flag -FHn -d skip "$pattern" "$1"
				fi
				shift
			done
		fi
		# Force return of 0 code to overcome zsh returning a spurious code of 2 when grepping
		return 0
	}

	_ftr() {
		if [[ $# -eq 0 || "$1" == "--help" || "$1" == "-h" || "$1" == "-?" ]] ; then
			cat <<EOT
ftr: recursively search files for a pattern
Usage: ftr [options] <pattern> [filespec ...]

ftr will do a recursive, case-insensitive text search using grep to print lines
in files in the current directory that match the pattern. If no filespec is
provided, all files in the current directory will be searched. If one or more
filespecs are provided, only files matching those filespecs will be searched.

Options
-c                 Search for pattern in a case sensitive fashion
-f or --filenames  Print only the filenames that match (don't print the matching
                   lines)

Examples:
ftr perl
ftr perl *.pl
ftr perl ~/roperdot
ftr perl ~/roperdot/*.pl
EOT
			return
		fi

		# Turn globbing back on
		[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && set +f || set +F

		local filename_flag case_flag=-i
		while [[ "$1" =~ ^- ]]; do
			[[ "$1" == "--" ]] && shift && break
			[[ "$1" == "--filenames" ]] && filename_flag=--files-with-matches && shift && continue
			[[ "$1" =~ [fF] ]] && filename_flag=--files-with-matches
			[[ "$1" =~ [cC] ]] && case_flag=
			shift
		done

		# Test for Mac (darwin) below since Mac's grep requires the last parameter
		# to be a directory when -r is used
		if [[ $# -eq 1 ]]; then
			if [[ "$ROPERDOT_OS_ENV" = "darwin" ]]; then
				grep -r $case_flag $filename_flag --include="*" -FHn "$1" .
			else
				grep -r $case_flag $filename_flag --include="*" -FHn "$1"
			fi
		else
			local pattern="$1"
			shift
			while [[ $# -gt 0 ]]; do
				if [[ -d "$1" ]]; then
					grep -r $case_flag $filename_flag -FHn "$pattern" "$1"
				elif [[ "$1" =~ / ]]; then
					local dir="${1%/*}"
					local filespec="${1##*/}"
					grep -r $case_flag $filename_flag --include="$filespec" -FHn "$pattern" "$dir"
				else
					if [ "$ROPERDOT_OS_ENV" = "darwin" ]; then
						grep -r $case_flag $filename_flag --include="$1" -FHn "$pattern" .
					else
						grep -r $case_flag $filename_flag --include="$1" -FHn "$pattern"
					fi
				fi
				shift
			done
		fi
	}
fi

is-archive() {
	re="\.(zip|ZIP|tar|gz|tgz|7z|rar|r00|Z|cbz|cbr|cbt|cb7|jar|war|ear|tz|taz|bz|bz2|tbz|tb2|tbz2|lzma|tlz|xz|txz|lha)$"
	[[ "$1" =~ $re ]] && echo true
}

cdclip() {
	local dest=$(clippaste)
	[[ "$dest" =~ ^~ && ! -d "$dest" ]] && dest="${dest/\~/$HOME}"
	if [[ "$ROPERDOT_DESKTOP_ENV" = "windows" ]] && [[ "$dest" =~ [:\\] ]]; then
		dest=$(wslpath "$dest")
	fi
	cd "$dest" || return 1
}

t() {
	if [[ "$1" == "--help" || "$1" == "-h" || "$1" == "-?" ]] ; then
		cat <<EOT
t: create a temporary directory
Usage: t

Creates a temporary directory within the current directory and will cd into it.
The first time this is used in a directory, it will create a directory named
"t" if it doesn't already exist. The next execution will create the directory
"t2", and then "t3", etc.
EOT
		return
	fi
	cd "$(make-t-dir)" || return 1
}

# Copy with progress
cpp() {
	rsync -Pav --no-perms "$1" "$2"
}

cr() {
	if [[ $# -eq 0 || "$1" == "--help" || "$1" == "-h" || "$1" == "-?" ]] ; then
		cat <<EOT
cr: Recursively compress files into an archive file
Usage: cr [-p <password>] [--verbose] <archive> [filespec ...]

Options:
-p <password>   Specify the password to use when compressing the archive
--verbose       Display the command used to compress the file

If no filespec is specified, all files in the current directory will be stored
in the archive (assuming the compressor being used accepts wildcards).

If the destination archive has a recognized archive extension it will be
created as a file of that type. Otherwise the archive will be created using
the default archive type that is stored in the arctype environment variable.

Valid values for the arctype variable are:

zip, 7z, gz, tar.gz, tgz, rar, bz2, tar.bz2, tbz, tbz2, tar.Z, tar.7z, xz,
tar.xz, txz, lzma, tar.lzma, tlz, tar.7z, and lha.

If the arctype is gz, bz2, Z, xz, or lzma the files will be compressed using
tar first.

Current arctype value: $arctype
EOT
		return
	fi
	c -r "$@"
}

#random() {
#	if [[ $# == 0 || "$1" == "--help" || "$1" == "-h" || "$1" == "-?" ]] ; then
#		cat <<EOT
#random: print a random number
#Usage: random [min] <max>
#
#Prints a random integer between and including the min and max values. If only
#max is supplied, min will default to 1.
#EOT
#		return
#	fi
#	local min
#	local max
#	if [[ $# == 1 ]]; then
#		min=1
#		max=$1
#	else
#		min=$1
#		max=$2
#	fi
#	[[ $max == % ]] && max=100
#	echo $((RANDOM % (max - min + 1) + min))
#}
#

if command -v whois >/dev/null 2>&1; then
	# whois a domain or a URL
	# Examples:
	# whois http://facebook.com
	# whois google.com
	function whois() {
		local domain=$(echo "$1" | awk -F/ '{print $3}')  # get domain from URL
		[[ -z "$domain" ]] && domain="$1"
		echo "Getting whois record for: $domain ..."

		# strip extra fluff
		\whois -h whois.internic.net "$domain" | sed '/NOTICE:/q'
	}
	
fi

# direct it all to /dev/null
nullify() {
	"$@" >/dev/null 2>&1
}

if command -v fzf >/dev/null 2>&1 && command -v git >/dev/null 2>&1; then
	# interactive git commit browser using fzf
	gli() {

		# Validate parameters
		[[ $(git log -n 1 "$@" | head -n 1) ]] || return

		# filter by file string
		local filter
		# if param is present show git log for file
		[[ -n "$@" && -f "$@" ]] && filter="-- $@"

		# git command
		local gitlog=(
			git log
			--graph --color=always
			--abbrev=7
			--format='%C(auto)%h %an %C(blue)%s %C(yellow)%cr'
			$@
		)

		# fzf command
		local fzf=(
			fzf
			--ansi --no-sort --reverse --tiebreak=index
			--preview "f() { set -- \$(echo -- \$@ | grep -o '[a-f0-9]\{7\}'); [ \$# -eq 0 ] || git show --color=always \$1 $filter; }; f {}"
			--bind "ctrl-q:abort,ctrl-m:execute:
				(grep -o '[a-f0-9]\{7\}' | head -1 |
				xargs -I % sh -c 'git show --color=always % $filter | less -R') << 'FZF-EOF'
				{}
				FZF-EOF"
			--preview-window=right:60%
		)

		"${gitlog[@]}" | "${fzf[@]}"
	}
fi

#count() {
#	[[ $# -eq 0 ]] && local dir="." || local dir="$1"
#	ls -ApR "$dir" | grep -v "/" | grep -v "^total" | grep -v "^\.:" | grep -v "^$" | wc -l
#}
#
#strlen() {
#	echo $(expr "$1" : '.*')
#}
#
#spawnapp() {
#	if [ -z "$2" ]; then
#		"$1" &
#	else
#		if [ "$ROPERDOT_DESKTOP_ENV" = "windows" ]; then
#			if [ -e "$2" ]; then
#				f=$(fix-path "$2")
#				"$1" "$f" &
#			else
#				"$1" "$2" &
#			fi
#		else
#			"$1" "$2" &
#		fi
#	fi
#}

source "${ROPERDOT_DIR}/source-scripts/initialize-colors"

initialize_colors

choose-scheme() {
	if [[ "$1" == "-?" || "$1" == "-h" || "$1" == "--help" ]]; then
		cat <<EOT
choose-scheme: choose a color scheme
Usage: choose-scheme [scheme-name]

Choose a color scheme from roperdot/config/color-schemes/source to use with
roperdot.

The color scheme will apply to:
* The bash prompt
* ls colors (.dircolors)
* vi
* man page highlighting
* Pygments (less)
* Generic Colouriser (multiple commands)
* git-blame-colored
* git (.gitcolors)
* Visual Studio Code
EOT
	else
		source "${ROPERDOT_DIR}/source-scripts/choose-scheme"
	fi
}

man() {
	LESS_TERMCAP_mb=$'\e'"[${COLOR_BRRED_CODE}m" \
	LESS_TERMCAP_md=$'\e'"[01;${COLOR_BLUE_CODE}m" \
	LESS_TERMCAP_me=$'\e[0m' \
	LESS_TERMCAP_se=$'\e[0m' \
	LESS_TERMCAP_so=$'\e'"[${COLOR_BRWHITE_CODE}m" \
	LESS_TERMCAP_ue=$'\e[0m' \
	LESS_TERMCAP_us=$'\e'"[04;${COLOR_BRMAGENTA_CODE}m" \
	command man "$@"
}

if [[ "$ROPERDOT_DESKTOP_ENV" = windows ]]; then
	appdata_wsl="$(win-env-linux-path APPDATA)"

	mount-drive() {
        if [[ $# -eq 0 || "$1" == "-?" || "$1" == "-h" || "$1" == "--help" ]]; then
            cat <<EOT
mount-drive: mount a drive in Windows
Usage: mount-drive <drive-letter>
This script will mount the specified drive letter to /mnt/<drive-letter>. If
the drive is already mounted, it will be unmounted first.
EOT
            return
        fi
        
        local drive="${1:l}"
        local mount_point="/mnt/$drive"
        
        # Unmount if already mounted
        while mountpoint -q "$mount_point" 2>/dev/null; do
            sudo umount "$mount_point"
        done
        
        [[ ! -d "$mount_point" ]] && sudo mkdir -p "$mount_point"
        
        # Mount with metadata option for proper timestamp preservation
        sudo mount -t drvfs -o rw,noatime,uid=1000,gid=1000,metadata,case=off "${drive:u}:" "$mount_point"
	}

	apply-mapped-drive() {
		local winpath="$1"
	    local distro_name unc_path mapped_drive
	    
	    distro_name="$WSL_DISTRO_NAME"
	    unc_path="\\\\wsl.localhost\\${distro_name}"
	    
	    # Check if there's a mapped drive to this UNC path
	    # Handle both "OK Z:" and "   Z:" formats (status column may be empty)
	    mapped_drive=$(net.exe use 2>/dev/null | grep -i "wsl.localhost\\\\${distro_name}" | awk '{for(i=1;i<=NF;i++) if($i ~ /^[A-Z]:$/) print $i}' | tr -d '\r')
	    
	    if [[ -n "$mapped_drive" ]]; then
	        winpath="${winpath//${unc_path}/${mapped_drive}}"
	    fi

	    printf '%s' "$winpath"
	}

	pwdwin() {
	    if [[ "$1" == "--help" || "$1" == "-h" || "$1" == "-?" ]]; then
	        cat <<EOT
pwdwin: Show the present working directory as a Windows path
Usage: pwdwin
EOT
	        return
	    fi
	    
	    local winpath
	    winpath=$(wslpath -w "$(pwd)")
	    
	    if [[ "$winpath" == *wsl.localhost* ]]; then
	    	winpath="$(apply-mapped-drive "$winpath")"
	    fi
	    
	    printf '%s\n' "$winpath"
	}

	winpath() {
		if [[ $# -eq 0 || "$1" == "--help" || "$1" == "-h" || "$1" == "-?" ]]; then
			cat <<EOT
winpath: Show the Windows path for a file
Usage: winpath <file>
EOT
			return
		fi
        
        local winpath
        winpath=$(wslpath -w "$1")
        if [[ "$winpath" == *wsl.localhost* ]]; then
	    	winpath="$(apply-mapped-drive "$winpath")"
	    fi
	    printf '%s\n' "$winpath"
	}

	claude_cache="${appdata_wsl}/Claude/Cache/Cache_Data"
	if [[ -d "$claude_cache" ]]; then
		clear-claude() {
			if [[ "$1" == "--help" || "$1" == "-h" || "$1" == "-?" ]]; then
				cat <<EOT
clear-claude: Clear the cache directory for Claude
Usage: clear-claude
EOT
				return
			fi
			local appdata_wsl="$(win-env-linux-path APPDATA)"
			local claude_cache="${appdata_wsl}/Claude/Cache/Cache_Data"
			setopt LOCAL_OPTIONS RM_STAR_SILENT
			\rm -rf "$claude_cache"/*
		}
	fi
fi

up() {
	if [[ "$1" == "--help" || "$1" == "-h" || "$1" == "-?" ]]; then
		cat <<EOT
up: cd up to a parent directory
Usage: up [prefix | count]

If a numeric count is provided, cd up that number of directories.

If a prefix string is provided, cd up to the first parent directory that begins
with the prefix.

If no arguments are provided, prompt the user to select the target directory
from a list. fzf will be used for the selection if it's installed.
EOT
		return
	fi
	local dest="$(_up "$@")"
	if [[ $? -eq 1 ]]; then
		echo "No matching parent directories"
	else
		cd "$dest" || return 1
	fi
}

cdj() {
	if [[ "$1" == "--help" || "$1" == "-h" || "$1" == "-?" ]]; then
		cat <<EOT
cdj: cd to a directory containing Java classes
Usage: cdj

This function finds directories containing .java files and lets you select one to
cd into.

The cached directory list is built from the 'code' directory.
If you're within a 'src' subdirectory, only directories under that src are shown.

Options:
  --build   Rebuild the directory cache
  filter    Optional case-insensitive filter for directory list

Display format:
  - Within src tree: Shows package path
  - Within code tree: Shows path from code

The directory list is cached at ~/.cache/cdj/dirs for performance. The cache is
is built from entire 'code' directory.

Additional directories:
  You can include additional directories (without .java files) by listing them in:
    ~/.config/cdj/additional-dirs.txt
  
  Format: One absolute path per line (tilde expansion supported)
EOT
		return
	fi
	local dest="$(_cdj "$@")"
	if [[ "$dest" =~ ^Error: ]]; then
		echo $dest
	elif [[ -n "$dest" ]]; then
		cd "$dest" || return 1
	fi
}

if command -v ydiff >/dev/null 2>&1; then
	diff() {
		if [[ $# -eq 2 && -f "$1" && -f "$2" ]]; then
			local f1="$1" f2="$2"
			shift 2
			command diff -u "$f1" "$f2" | ydiff -s "$@"
		else
			command diff "$@"
		fi
	}
fi

modtime() {
	if [[ $# -eq 0 || ! -f "$1" ]]; then
		cat <<EOT
modtime: print the modified time for a file
Usage: modtime <filespec>

Prints the modified time for a file in a format that is compatible with the
touch command.
EOT
		return
	fi
	local t=$(stat -c "%y" "$1")
	# Remove decimal point and characters after
	t="${t%.*}"
	# Remove first colon, replace remaining colon with decimal point, and remove dashes and spaces
	echo "${t/:/}" | tr ':' '.' | tr -d '-' | tr -d ' '
}

_rolln() {
	local count=$1
	shift
	roll -n $count "$@"
}

_u() {
	# Turn globbing back on
	[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && set +f || set +F

	perl "${ROPERDOT_DIR}/scripts/u.pl" "$@"
}

bindiff() {
	[[ -n "$diff_app" ]] || diff_app=$0
	if [[ $# -ne 2 ]]; then
		cat <<EOT
$diff_app: compare files in binary/hex mode
Usage: $diff_app <filespec> <filespec>

To exit vimdiff in simple mode, press ctrl-L and then do :qa!
EOT
		return
	fi
	if ! command -v vimdiff >/dev/null 2>&1; then
		echo "Required application vimdiff not found"
		return
	fi
	vimdiff -y <(xxd -l1000 "$1") <(xxd -l1000 "$2") 2>/dev/null
}

hexdiff() {
	diff_app=$0 bindiff "$@"
}

jsondiff() {
    if [[ $# -lt 2 ]]; then
		cat <<EOT
jsondiff: compare two JSON files side-by-side
Usage: jsondiff file1.json file2.json [width]
EOT
        return 1
    fi

    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jsondiff requires jq" >&2
        return 1
    fi

    local file1="$1"
    local file2="$2" 
    local width="${3:-0}"  # 0 = auto-width
    local temp1=$(mktemp)
    local temp2=$(mktemp)
    
    # Normalize JSON
    jq --sort-keys . "$file1" > "$temp1" || {
        echo "Invalid JSON: $file1" >&2
        rm -f "$temp1" "$temp2" >/dev/null
        return 1
    }
    jq --sort-keys . "$file2" > "$temp2" || {
        echo "Invalid JSON: $file2" >&2
        rm -f "$temp1" "$temp2" >/dev/null
        return 1
    }
    
    if command -v ydiff >/dev/null 2>&1; then
        if [[ "$width" = "0" ]]; then
            diff -u --label="$file1" --label="$file2" "$temp1" "$temp2" | ydiff -s
        else
            diff -u --label="$file1" --label="$file2" "$temp1" "$temp2" | ydiff -s -w "$width"
        fi
    else
        diff -u --label="$file1" --label="$file2" "$temp1" "$temp2"
    fi
    
    rm -f "$temp1" "$temp2" >/dev/null
}