#
# Description: Bootstrap script for roperdot dotfiles
#
# Author: Andy Roper <andyroper42@gmail.com>
# URL: https://github.com/andy-roper/roperdot
#

# Files that are part of this package:
# roperdot-bootstrap: this file
# .aliases: aliases not specific to an OS
# .functions: functions not specific to an OS
# .roperdot-os-<os>: OS-specific bash configs
# install.sh: roperdot install script
# install-apps: script for installing necessary/useful apps to use with this package
# roperdot-setup.txt: package setup document
# *-shell-apps.json: shell application definitions by OS
# *-gui-apps.json: GUI application definitions by OS
# source-scripts: scripts to be sourced
# app-bin-bash: application-calling scripts for bash; generated by update-app-binaries
# app-bin-zsh: application-calling scripts for zsh; generated by update-app-binaries
# bin: sh, JavaScript and Perl scripts
# bin-scripts: shell script source
# bin-scripts/<os>: shell scripts for a specific OS
# bin-bash: copies of scripts in bin-scripts with a bash shebang
# bin-zsh: copies of scripts in bin-scripts with a zsh shebang
# config/apps: configuration files for applications
# config/color-schemes: color scheme files for applications
# extra-bin: binaries for installed applications
# install-profiles: installation profiles
#
#
# Files created during install:
# ~/roperdot-loader: loader script with user-specific settings
# ~/.roperdot-os-functions: generated file containing OS-specific functions based on installed apps
# ~/.extra: personal aliases/functions/variables that you define
#
# Environment Variables:
# ROPERDOT_OS_NAME: Name of OS. Supported values are ubuntu, centos and darwin.
# ROPERDOT_OS_ENV: OS and environment. Supported values are ubuntu, kubuntu, centos, centos-gnome, rhel, darwin, raspbian
# ROPERDOT_DESKTOP_ENV: Supported values are gnome, kde, windows and mac
# ROPERDOT_HISTORY_BY_SESSION: true if each terminal session has its own history file
# ROPERDOT_SHOW_EXTENDED_GIT_INFO: set if showing extended git information in the prompt
# ROPERDOT_COLOR_SCHEME: color scheme to use
# ROPERDOT_DEFAULT_COMMON_COLOR_SCHEME: color scheme to use if ROPERDOT_COMMON_COLOR_SCHEME is set to default
# ROPERDOT_COMMON_COLOR_SCHEME: color scheme to use for pygmentize
# ROPERDOT_ARC_TYPE: default archive type when creating archives using the c script
# EDITOR: default editor
# 
# If you want to associate a new application with an edit/view function, make the necessary updates to
# bin/update-app-binaries in the roperdot directory and run it. This will regenerate ~/.roperdot-os-functions
# and the binaries in ~/roperdot/app-bin-bash and ~/roperdot/app-bin-zsh.

# TO DO
# Maybe look into having a script to run to toggle using default prompt or custom prompt

# If not running interactively, don't do anything
[[ $- == *i* ]] || return

if [[ -z "$ROPERDOT_SUPPRESS_INFO" && -e ~/roperdot-info.txt ]]; then
	echo -e "Set ROPERDOT_SUPPRESS_INFO to true in ~/roperdot-loader to stop seeing these messages.\n"
	cat ~/roperdot-info.txt
fi

if [[ -n "$BASH_VERSION" ]]; then
	export ROPERDOT_CURRENT_SHELL=bash
	ROPERDOT_SHELL_VERSION="$(bash --version | awk -F"version " '{print $2;exit;}')"
	export ROPERDOT_SHELL_VERSION="${ROPERDOT_SHELL_VERSION%%.*}"
	export ROPERDOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
elif [[ -n "$ZSH_VERSION" ]]; then
	export ROPERDOT_CURRENT_SHELL=zsh
	ROPERDOT_SHELL_VERSION="$(zsh --version)"
	ROPERDOT_SHELL_VERSION="${ROPERDOT_SHELL_VERSION#zsh }"
	export ROPERDOT_SHELL_VERSION="${ROPERDOT_SHELL_VERSION%%.*}"
	export ROPERDOT_DIR="$(cd "$(dirname "${(%):-%N}")" && pwd)"
fi

# SHOW_TIMING=true
source "${ROPERDOT_DIR}/source-scripts/do-timing"
do_timing "phase 1a"

export LOCAL=~/.local
export LOCALUSR=$LOCAL/usr
[[ -d "${LOCALUSR}/bin" ]] || mkdir -p "${LOCALUSR}/bin"
[[ -d "${ROPERDOT_DIR}/extra-bin" ]] || mkdir "${ROPERDOT_DIR}/extra-bin"

do_timing "phase 1b"
source "${ROPERDOT_DIR}/source-scripts/detect-os"

# Update module_path if in zsh and using local Homebrew install
if [[ "$ROPERDOT_CURRENT_SHELL" = zsh && -d ~/homebrew/lib/zsh ]]; then
    module_path=(~/homebrew/lib/zsh $module_path)
fi

do_timing "phase 1c"
if [[ -f "$ROPERDOT_DIR/VERSION" ]]; then
    CURRENT_VERSION=$(cat "$ROPERDOT_DIR/VERSION" 2>/dev/null | tr -d '\n\r ')
else
    CURRENT_VERSION=""
fi
if [[ "$CURRENT_VERSION" != "$ROPERDOT_VERSION" ]] || [[ -z "$CURRENT_VERSION" ]]; then
	echo "Copying scripts to ${ROPERDOT_DIR}/bin-${ROPERDOT_CURRENT_SHELL}"
	ROPERDOT_SHELL_TO_COPY=$ROPERDOT_CURRENT_SHELL
	source "${ROPERDOT_DIR}/source-scripts/copy-scripts"
	"$ROPERDOT_DIR/bin/generate-help"
	unset ROPERDOT_SHELL_TO_COPY
    sed -i.bak "s/^export ROPERDOT_VERSION=.*/export ROPERDOT_VERSION=$CURRENT_VERSION/" ~/roperdot-loader
fi

do_timing "phase 1d"
if [[ -n $ROPERDOT_DESKTOP_ENV && ! -e "${ROPERDOT_DIR}/app-bin-${ROPERDOT_CURRENT_SHELL}/text-editor-app" ]]; then
	echo "Copying scripts to ${ROPERDOT_DIR}/app-bin-${ROPERDOT_CURRENT_SHELL}"
	[[ $ROPERDOT_CURRENT_SHELL = bash ]] && export PROCESSING_BASH=true || export PROCESSING_ZSH=true
	"${ROPERDOT_DIR}/bin-${ROPERDOT_CURRENT_SHELL}/update-app-binaries"
	[[ $ROPERDOT_CURRENT_SHELL = bash ]] && unset PROCESSING_BASH || unset PROCESSING_ZSH
fi
do_timing "phase 1e"
source "${ROPERDOT_DIR}/source-scripts/re-match"
do_timing "phase 1f"
source "${ROPERDOT_DIR}/source-scripts/realpath"
do_timing "phase 1g"
source "${ROPERDOT_DIR}/source-scripts/abs-path"
do_timing "phase 1h"
[[ -n "$ROPERDOT_USE_VIM_SETTINGS" ]] && . "${ROPERDOT_DIR}/source-scripts/check-vi"
do_timing "phase 1i"
[[ -d ~/homebrew ]] && eval "$(~/homebrew/bin/brew shellenv)"
# Do this after the homebrew evaluation to ensure roperdot bin directories precede homebrew directories
PATH="${ROPERDOT_DIR}/bin-${ROPERDOT_CURRENT_SHELL}:${ROPERDOT_DIR}/bin:$PATH"
[[ -f "${ROPERDOT_DIR}/.roperdot-os-${ROPERDOT_OS_NAME}" ]] && source "${ROPERDOT_DIR}/.roperdot-os-${ROPERDOT_OS_NAME}"

# Implemented to work around Python externally-managed-environment errors
current_python="$(command -v python3)"
if [[ -f /usr/bin/python3 ]] && [[ "$current_python" == "/usr/local/bin/python3" || "$current_python" == */homebrew/bin/python3 ]] && [[ ! -f "${ROPERDOT_DIR}/extra-bin/python3" ]]; then
	[[ -d "${ROPERDOT_DIR}/extra-bin" ]] || mkdir "${ROPERDOT_DIR}/extra-bin"
    ln -sf /usr/bin/python3 "${ROPERDOT_DIR}/extra-bin/python3"
    ln -sf /usr/bin/pip3 "${ROPERDOT_DIR}/extra-bin/pip3"
fi

#time_event() {
#	[[ -z "$debugging" || -z "$start_time" ]] && return
#	[[ -n "$1" ]] && echo "$1: $(( ($(date +%s%N) - start_time) / 1000000)) ms"
#	start_time=$(date +%s%N)
#}

[[ -z "$MANPATH" ]] && MANPATH="$(manpath)"

do_timing "phase 2a"

[[ -d "${LOCAL}/bin" ]] && PATH="${LOCAL}/bin:$PATH"
PATH="${LOCALUSR}/bin:$PATH"
re=/usr/local/bin
# For Perl-compatible regexes to work with brew-installed zsh on Mac, /usr/local/bin must precede /usr/bin in PATH
# [[ -d "/usr/local/bin" && ! "$PATH" =~ $re ]] && PATH="$PATH:/usr/local/bin"
[[ -d "/usr/local/bin" && ! "$PATH" =~ $re ]] && PATH="/usr/local/bin:$PATH"

if ! command -v python >/dev/null 2>&1 && [[ -f /usr/bin/python3 ]]; then
    ln -sf /usr/bin/python3 "${ROPERDOT_DIR}/extra-bin/python"
fi

do_timing "phase 2b"
# if command -v npm >/dev/null 2>&1 && [[ ! "$PATH" =~ npm ]]; then
# 	npmdir="$(npm bin -g 2>/dev/null)"
# 	if [[ "$ROPERDOT_DESKTOP_ENV" = windows && "$ROPERDOT_OS_ENV" = ubuntu ]]; then
# 		d="$(wslpath "$npmdir" 2>&1)"
# 		[[ -n "$d" ]] && npmdir="$d"
# 	fi
# 	PATH="$PATH:$npmdir"
# fi

do_timing "phase 2c"
if [[ -d ~/.npm-packages ]]; then
	export NPM_PACKAGES="${HOME}/.npm-packages"
	PATH="$NPM_PACKAGES/bin:$PATH"
	[[ -d "$NPM_PACKAGES/share/man" ]] && MANPATH="$NPM_PACKAGES/share/man:$MANPATH"
fi
export INPUTRC="${ROPERDOT_DIR}/.inputrc"

[[ -d "${ROPERDOT_DIR}/os-bin/${ROPERDOT_OS_TYPE}" ]] && PATH="${ROPERDOT_DIR}/os-bin/${ROPERDOT_OS_TYPE}:$PATH"
[[ -d "${ROPERDOT_DIR}/extra-bin" ]] && PATH="${ROPERDOT_DIR}/extra-bin:$PATH"
[[ $ROPERDOT_CURRENT_SHELL == bash && -d "${ROPERDOT_DIR}/app-bin-bash" ]] && PATH="${ROPERDOT_DIR}/app-bin-bash:$PATH"
[[ $ROPERDOT_CURRENT_SHELL == zsh && -d "${ROPERDOT_DIR}/app-bin-zsh" ]] && PATH="${ROPERDOT_DIR}/app-bin-zsh:$PATH"

[[ -d "${LOCALUSR}/share/man" ]] && MANPATH="${MANPATH}:${LOCALUSR}/share/man"
[[ -d "${LOCALUSR}/man" ]] && MANPATH="${MANPATH}:${LOCALUSR}/man"
[[ -d "${LOCAL}/man" ]] && MANPATH="${MANPATH}:${LOCAL}/man"
[[ -d "${LOCAL}/share/man" ]] && MANPATH="${MANPATH}:${LOCAL}/share/man"
[[ -d "${ROPERDOT_DIR}/man" ]] && MANPATH="${MANPATH}:${ROPERDOT_DIR}/man"
export MANPATH

# For groff 1.23.0 compatibility, set GROFF_NO_SGR to an empty string to enable SGR codes and enable colors in man
export GROFF_NO_SGR=

do_timing "phase 3"

if [[ "$ROPERDOT_USE_VIM_SETTINGS" = true ]]; then
	[[ -d ~/.vim/backup ]] || mkdir ~/.vim/backup
	[[ -d ~/.vim/swap ]] || mkdir ~/.vim/swap
	[[ -d ~/.vim/undo ]] || mkdir ~/.vim/undo
	if [[ -e ~/.vimrc-roperdot ]]; then
		[[ -e ~/.vimrc ]] && \mv ~/.vimrc ~/.vimrc.bak
		\cp ~/.vimrc-roperdot ~/.vimrc
	fi
	[[ -d "${ROPERDOT_DIR}/neovim-runtime" ]] && export VIM="${ROPERDOT_DIR}/neovim-runtime"
	[[ -e ~/.vi-plugin-init ]] && . ~/.vi-plugin-init
fi

# Fix brew "parent directory is world writable but not sticky" error in WSL
[[ "$ROPERDOT_OS_ENV" = "ubuntu" && "$ROPERDOT_DESKTOP_ENV" = "windows" ]] && umask 022

# autoload must execute before .functions is sourced so it runs before compdef executions
if [[ "$ROPERDOT_CURRENT_SHELL" = zsh ]]; then
	# Auto-fix insecure directory permissions before compinit
	if ! compaudit >/dev/null 2>&1; then
		# compaudit found issues, try to fix them automatically
		compaudit 2>/dev/null | xargs chmod g-w,o-w 2>/dev/null || true
	fi

	# Initialize the completion system
	autoload -Uz compinit && compinit
	error_code=$?
	if [[ $error_code -ne 0 && "$ROPERDOT_OS_ENV" = "darwin" ]]; then
		read "?Error detected starting compinit. Fix by changing permissions on /usr/local/share [y/n]? "
		if [[ "$REPLY" = y ]]; then
			chmod -R go-w /usr/local/share
			autoload -Uz compinit && compinit
		fi
	fi
	[[ -e "$ROPERDOT_DIR/.zsh-suffix-aliases" ]] && . "$ROPERDOT_DIR/.zsh-suffix-aliases"

	# Configure completion quoting for better VS Code compatibility
	zstyle ':completion:*' special-dirs true
	zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'
	zstyle ':completion:*' quote-style shell
fi

do_timing "phase 4"
[[ -f "${ROPERDOT_DIR}/.aliases" ]] && source "${ROPERDOT_DIR}/.aliases"
do_timing "phase 5"
[[ -f "${ROPERDOT_DIR}/.functions" ]] && source "${ROPERDOT_DIR}/.functions"
do_timing "phase 6"

set +f

[[ -f ~/.extra ]] && source ~/.extra
[[ -f "${ROPERDOT_DIR}/.extra" ]] && source "${ROPERDOT_DIR}/.extra"
[[ -f "${ROPERDOT_DIR}/.cross-platform" ]] && source "${ROPERDOT_DIR}/.cross-platform"
[[ -f ~/.roperdot-os-functions ]] && source ~/.roperdot-os-functions
do_timing "phase 7"

#for file in ~/extra-source/*; do
#	[[ -f "$file" ]] && source "$file"
#done
#unset file

if command -v brew >/dev/null 2>&1 && zpath="$(brew --prefix)/etc/profile.d/z.sh" && [[ -e "$zpath" ]];	then
	source "$zpath"
elif [[ -e "${ROPERDOT_DIR}/extra-bin/z.sh" ]]; then
	source "${ROPERDOT_DIR}/extra-bin/z.sh"
fi

# Export _z to subshells if it's defined
# command -v _z >/dev/null 2>&1 && export -f _z

# Update values of LINES and COLUMNS after the window is sized
[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && shopt -s checkwinsize
export COLUMNS

# Enable autocompletion of directories; treat a directory name as a cd command
if [[ "$ROPERDOT_CURRENT_SHELL" = bash ]]; then
	[[ "$ROPERDOT_SHELL_VERSION" -gt 3 ]] && shopt -s autocd 2> /dev/null
else
	setopt autocd
fi

# make less more friendly for non-text input files, see lesspipe(1)
# command -v lesspipe >/dev/null 2>&1 && eval "$(SHELL=/bin/sh lesspipe)"

[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && trap 'export bash_command=$BASH_COMMAND' DEBUG

# Don't clear the screen after quitting a manual page
export MANPAGER="less -X"

# Prefer US English and use UTF-8
# Set locale with fallback
# Try to set UTF-8 locale with fallback chain
for locale_candidate in "en_US.UTF-8" "en_US.utf8" "C.UTF-8" "C.utf8"; do
    if locale -a 2>/dev/null | grep -qFx "$locale_candidate"; then
        export LC_ALL="$locale_candidate"
        export LANG="$locale_candidate"
        break
    fi
done

# If nothing worked, fall back to C
[[ -z "$LANG" ]] && export LANG="C"

if [[ -d /home/linuxbrew/.linuxbrew/bin ]]; then
	export PATH="$PATH:/home/linuxbrew/.linuxbrew/bin"
	export MANPATH="$MANPATH:/home/linuxbrew/.linuxbrew/share/man"
	export INFOPATH="$INFOPATH:/home/linuxbrew/.linuxbrew/share/info"
fi

if [[ -f "${LOCALUSR}/bin/mc" ]]; then
	if [[ -n "$LD_LIBRARY_PATH" ]]; then
		export LD_LIBRARY_PATH="${LD_LIBRARY_PATH}:${LOCALUSR}/lib/x86_64-linux-gnu"
	else
		export LD_LIBRARY_PATH="${LOCALUSR}/lib/x86_64-linux-gnu"
	fi
	export MC_DATADIR="${LOCALUSR}/share/mc"
fi

if command -v fzf >/dev/null 2>&1; then
	if [[ "$ROPERDOT_OS_NAME" = ubuntu ]] && command -v fdfind >/dev/null 2>&1; then
		have_fd=true
	elif command -v fd >/dev/null 2>&1; then
		have_fd=true
	fi
	if [[ -n "$have_fd" ]]; then
		export R_DEFAULT_COMMAND='fd --type file --follow --hidden --exclude .git'
		export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
		export FZF_DEFAULT_OPTS="--extended"
		unset have_fd
	fi
fi

# ------------------------------------------------------------------------------------

# History-related

do_timing "phase 8"

if [[ "$ROPERDOT_CURRENT_SHELL" = bash ]]; then
    if [[ -z "$_fzf_completion_loader" ]]; then
        [[ -e ~/.fzf.bash ]] && . ~/.fzf.bash
    fi
elif [[ "$ROPERDOT_CURRENT_SHELL" = zsh ]]; then
    if [[ -z "$fzf_default_completion" ]]; then
        [[ -e ~/.fzf.zsh ]] && . ~/.fzf.zsh
    fi
fi

if [[ -n "$ROPERDOT_HISTORY_BY_SESSION" ]]; then
	store_history () {
		history -a
	}
else
	store_history () {
		history -a
		history -c
		history -r
	}
fi

if [[ -n "$ROPERDOT_HISTORY_BY_SESSION" ]]; then
	export HISTSIZE=2000
	export HISTFILESIZE=2000
	# Define history file with PID as extension
	export HISTFILE=$HOME/.bash_history.$$
	# Delete history files for inactive sessions
	while IFS= read -r -d '' hf; do
		if re_match "$hf" '\.([0-9]+)$'; then
		    pid="${re_match[1]}"
		    # Just check if PID exists (any process)
		    kill -0 "$pid" 2>/dev/null || \rm "$hf"
		fi
	done < <(find ~ -maxdepth 1 -name ".bash_history.*" -print0)
	# Delete history file on shell exit
	trap '\rm -f "$HISTFILE"' 0
else
	export HISTSIZE=100000
	export HISTFILESIZE=$HISTSIZE
	[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && shopt -s histappend
fi

# Enable history expansion with space
# Typing !!<space> will replace the !! with your last command
[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && bind Space:magic-space

# Use standard ISO 8601 timestamp
# %F equivalent to %Y-%m-%d
# %T equivalent to %H:%M:%S (24-hour format)
export HISTTIMEFORMAT='%F %T '

# Don't record some commands
export HISTIGNORE="&:[ ]*:exit:ls:bg:fg:history:clear:cls"

# don't include spaces in history
export HISTCONTROL=ignorespace

# Save multi-line commands as one command
[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && shopt -s cmdhist

# ------------------------------------------------------------------------------------

# Colors and prompt

do_timing "phase 9a"

if [[ "$COLORTERM" = gnome-* && "$TERM" = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
    export TERM=gnome-256color
elif infocmp xterm-256color >/dev/null 2>&1; then
    export TERM=xterm-256color
fi

if [[ "$TERM_PROGRAM" == "Apple_Terminal" ]]; then
    export TERM=xterm-256color # Force 256-color mode for other apps too
    unset COLORTERM  # Don't advertise 24-bit support
    # Vim: Use 256-color compatible colorscheme
    export VIM_COLOR_MODE="256color"
fi

do_timing "phase 9b"
#if [[ -n "$ROPERDOT_COLOR_SCHEME" ]]; then
#	if command -v tput >/dev/null 2>&1 && tput setaf 1 >/dev/null 2>&1; then
#		# 256 colors
#		source "${ROPERDOT_DIR}/.define_colors.${ROPERDOT_COLOR_SCHEME}.256"
#	else
#		# 16 colors
#		source "${ROPERDOT_DIR}/.define_colors.16-color"
#	fi
#fi

do_timing "phase 9c"
export CLICOLOR=1
[[ "$ROPERDOT_OS_ENV" = "darwin" ]] && export CLICOLOR_FORCE=1

do_timing "phase 9d"
initialize_colors

do_timing "phase 9e"
# [[ "$ROPERDOT_CURRENT_SHELL" = bash && -e "${ROPERDOT_DIR}/.bash_prompt" ]] && source "${ROPERDOT_DIR}/.bash_prompt"

# export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

do_timing "phase 9f"
# Moved setting LESS_TERMCAP env vars to man function

export LESS='-MR'

do_timing "phase 9g"
if command -v pygmentize >/dev/null 2>&1; then
#	command -v tput >/dev/null 2>&1 && tput setaf 1 >/dev/null 2>&1 && colors=256 || colors=16
#	lessfilter="${ROPERDOT_DIR}/lessfilter-${colors}-${ROPERDOT_CURRENT_SHELL}"
	lessfilter="${ROPERDOT_DIR}/bin-${ROPERDOT_CURRENT_SHELL}/lessfilter"
	export LESSOPEN="|\"$lessfilter\" %s"
	[[ -e "$lessfilter" && ! -x "$lessfilter" ]] && chmod u+x "$lessfilter"
	unset colors lessfilter
fi

# ------------------------------------------------------------------------------------

# Completion

do_timing "phase 10"

# Enable extended pattern matching
[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && shopt -s extglob || setopt ksh_glob

# Case-insensitive globbing (used in pathname expansion)
if [[ "$ROPERDOT_CURRENT_SHELL" = bash ]]; then
	shopt -s nocaseglob
else
	unsetopt case_glob
	# Do case-insensitive tab completion in zsh
	zstyle ':completion:*' matcher-list 'm:{[:lower:][:upper:]}={[:upper:][:lower:]}' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*'
fi

# Autocorrect for arguments supplied to cd and for directory names to match a glob
#if [[ "$ROPERDOT_CURRENT_SHELL" = bash ]]; then
#	shopt -s cdspell dirspell 2>/dev/null
#else
#	setopt correct correct_all
#fi

# Turn on recursive globbing (enables ** to recurse all directories)
[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && shopt -s globstar 2> /dev/null

# Eliminate "No match found" message when globbing doesn't match
[[ "$ROPERDOT_CURRENT_SHELL" = zsh ]] && setopt +o nomatch

# bash_completion is sourced for macOS in its .roperdot-os file

# Enable tab completion for "g" by marking it as an alias for "git"
command -v __git_complete >/dev/null 2>&1 && __git_complete g __git_main

# Fix broken links to configuration files
#if [[ -L "/usr/local/bin/grcat" && ! -e "/usr/local/bin/grcat" ]]; then
#	echo "Fixing link for /usr/local/bin/grcat"
#	ln -sf "${ROPERDOT_DIR}/extra-bin/grcat" /usr/local/bin/grcat
#fi

# source grc file if present
if command -v grc >/dev/null 2>&1; then
	if [[ "$ROPERDOT_CURRENT_SHELL" = zsh ]]; then
		grcfile=grc.zsh
	else
		grcfile=grc.sh
	fi
	if command -v brew >/dev/null 2>&1; then
		grcfilepath="$(brew --prefix)/etc/$grcfile"
	elif command -v apt >/dev/null 2>&1; then
		grcfilepath="/usr/share/grc/$grcfile"
	fi
	[[ -n "$grcfilepath" && -f "$grcfilepath" ]] && . "$grcfilepath"
fi

# Define diff after grc processing to override the grc-generated function
if command -v ydiff >/dev/null 2>&1; then
	diff() {
		if [[ $# -eq 2 && -f "$1" && -f "$2" ]]; then
			local f1="$1" f2="$2"
			shift 2
			command diff -u "$f1" "$f2" | ydiff -s "$@"
		else
			command diff "$@"
		fi
	}
fi

# fix-link ".dircolors"
# link_files=(".git_colors" ".gitconfig" ".gitconfig.local" ".gitignore")
link_files=(".gitconfig" ".gitconfig.local" ".gitignore")
for link_file in "${link_files[@]}"; do
	if fix-link "$link_file" true; then
		admin_link_failure=true
		break
	fi
done
unset link_files

if [[ "$ROPERDOT_CURRENT_SHELL" = zsh ]]; then
	# File completion (can match files in subdirectories)
	compdef '_files' chmox d2u decrypt e encrypt fs la lsd modtime sha1 sha1bin sha256 sha256bin v vb vt

	# Directory completion
	compdef '_directories' fm cpp cpr

	# Archive file completion
	compdef '_files -g "*.zip" -g "*.7z" -g "*.rar" -g "*.tar" -g "*.tar.gz" -g "*.tgz" -g "*.cbr" -g "*.cbz"' x xd

	# Directory and archive completion
	compdef '_files -/ -g "*.zip" -g "*.7z" -g "*.rar" -g "*.tar" -g "*.tar.gz" -g "*.tgz" -g "*.cbr" -g "*.cbz" -g "*.dmg" -g "*.iso"' cd

	# JSON file completion
	compdef '_files -g "*.json"' format-json-file

	# format-specific completion
	compdef '_files -g "*.sql" -g "*.json" -g "*.js" -g "*.html" -g "*.css"' format
fi

# Pre-calculate prompt colors (used by set_git_info)
PROMPT_RESET=$(printf '\033[0m')
PROMPT_TRIANGLE=$(printf '\uE0B0')

PROMPT_GREEN_FG=$(printf '\033[0;%sm' "${COLOR_GREEN_CODE}")
PROMPT_GREEN_BG=$((COLOR_GREEN_CODE + 10))
PROMPT_BLACK_ON_GREEN=$(printf '\033[0;%s;%sm' "${COLOR_BLACK_CODE}" "${PROMPT_GREEN_BG}")

PROMPT_YELLOW_FG=$(printf '\033[0;%sm' "${COLOR_YELLOW_CODE}")
PROMPT_YELLOW_BG=$((COLOR_YELLOW_CODE + 10))
PROMPT_BLACK_ON_YELLOW=$(printf '\033[0;%s;%sm' "${COLOR_BLACK_CODE}" "${PROMPT_YELLOW_BG}")

PROMPT_BLACK_BG=$((COLOR_BLACK_CODE + 10))

# For Apple Terminal
PROMPT_GREEN_INITIAL_TRIANGLE=$(printf '\033[%s;%sm' "${PROMPT_GREEN_BG}" "${COLOR_BLACK_CODE}")
PROMPT_GREEN_ON_BLACK=$(printf '\033[0;%s;40m' "${COLOR_GREEN_CODE}")
PROMPT_YELLOW_INITIAL_TRIANGLE=$(printf '\033[%s;%sm' "${PROMPT_YELLOW_BG}" "${COLOR_BLACK_CODE}")
PROMPT_YELLOW_ON_BLACK=$(printf '\033[0;%s;40m' "${COLOR_YELLOW_CODE}")

# For non-Apple Terminal
PROMPT_GREEN_INITIAL_TRIANGLE_BLUE=$(printf '\033[%s;%sm' "${PROMPT_GREEN_BG}" "${COLOR_BLUE_CODE}")
PROMPT_YELLOW_INITIAL_TRIANGLE_BLUE=$(printf '\033[%s;%sm' "${PROMPT_YELLOW_BG}" "${COLOR_BLUE_CODE}")

build_git_status_info() {
	local is_clean="$1" info_text="$2"
    if [[ "$is_clean" == true ]]; then
        if [[ "$TERM_PROGRAM" == "Apple_Terminal" ]]; then
            export GIT_STATUS_INFO="${PROMPT_GREEN_INITIAL_TRIANGLE}${PROMPT_TRIANGLE}${PROMPT_BLACK_ON_GREEN} ${info_text} ${PROMPT_GREEN_ON_BLACK}${PROMPT_TRIANGLE}${PROMPT_RESET}"
        else
            export GIT_STATUS_INFO="${PROMPT_GREEN_INITIAL_TRIANGLE_BLUE}${PROMPT_TRIANGLE}${PROMPT_BLACK_ON_GREEN} ${info_text} ${PROMPT_GREEN_FG}${PROMPT_TRIANGLE}${PROMPT_RESET}"
        fi
    else
        if [[ "$TERM_PROGRAM" == "Apple_Terminal" ]]; then
            export GIT_STATUS_INFO="${PROMPT_YELLOW_INITIAL_TRIANGLE}${PROMPT_TRIANGLE}${PROMPT_BLACK_ON_YELLOW} ${info_text} ${PROMPT_YELLOW_ON_BLACK}${PROMPT_TRIANGLE}${PROMPT_RESET}"
        else
            export GIT_STATUS_INFO="${PROMPT_YELLOW_INITIAL_TRIANGLE_BLUE}${PROMPT_TRIANGLE}${PROMPT_BLACK_ON_YELLOW} ${info_text} ${PROMPT_YELLOW_FG}${PROMPT_TRIANGLE}${PROMPT_RESET}"
        fi
    fi
}

if [[ -n "$ROPERDOT_SHOW_EXTENDED_GIT_INFO" ]]; then
	function set_git_info() {
	    if ! git rev-parse --git-dir >/dev/null 2>&1; then
	    	export GIT_STATUS_INFO=""
	    	return
	    fi

	    local branch=$(git branch --show-current 2>/dev/null)
	    
        local status_output=$(git status --porcelain 2>/dev/null)
        
        local staged=0 unstaged=0 untracked=0 conflicted=0
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            local index_status="${line:0:1}"
            local work_tree_status="${line:1:1}"
            
            [[ "$index_status" != " " && "$index_status" != "?" ]] && ((staged++))
            [[ "$work_tree_status" != " " && "$work_tree_status" != "?" ]] && ((unstaged++))
            [[ "$index_status" == "?" ]] && ((untracked++))
            [[ "$index_status" == "U" || "$work_tree_status" == "U" || "$index_status" == "A" && "$work_tree_status" == "A" ]] && ((conflicted++))
        done <<< "$status_output"
        
        local ahead=0 behind=0
        if git rev-parse --verify @{upstream} >/dev/null 2>&1; then
            local ahead_behind=$(git rev-list --count --left-right @{upstream}...HEAD 2>/dev/null)
            behind=${ahead_behind%	*}
            ahead=${ahead_behind#*	}
        fi
        
        local stashes=0
        if git rev-parse --verify refs/stash >/dev/null 2>&1; then
            stashes=$(git rev-list --walk-reflogs --count refs/stash 2>/dev/null || echo 0)
        fi
        
        local is_clean=false
        [[ $staged -eq 0 && $unstaged -eq 0 && $untracked -eq 0 && $conflicted -eq 0 ]] && is_clean=true
        
        local status_indicators=""
        if [[ "$is_clean" == false ]]; then
	        [[ $staged -gt 0 ]] && status_indicators+=" +$staged"
	        [[ $unstaged -gt 0 ]] && status_indicators+=" !$unstaged"
	        [[ $untracked -gt 0 ]] && status_indicators+=" ?$untracked"
	        [[ $conflicted -gt 0 ]] && status_indicators+=" ~$conflicted"
        fi
        [[ $ahead -gt 0 ]] && status_indicators+=" ⇡$ahead"
        [[ $behind -gt 0 ]] && status_indicators+=" ⇣$behind"
        [[ $stashes -gt 0 ]] && status_indicators+=" *$stashes"
        local info_text="${branch}${status_indicators}"

        build_git_status_info $is_clean "$branch"
	}
else
	function set_git_info() {
	    if ! git rev-parse --git-dir >/dev/null 2>&1; then
	    	export GIT_STATUS_INFO=""
	    	return
	    fi

	    local branch=$(git branch --show-current 2>/dev/null)
	    
	    local is_clean=false
	    if git diff-index --quiet HEAD -- 2>/dev/null && \
	    [[ -z $(git ls-files --others --exclude-standard 2>/dev/null) ]]; then
	        is_clean=true
	    fi

	    build_git_status_info $is_clean "$branch"
	}
fi

set_terminal_title () {
#	local display_path="${USER}@${HOST%%.*}"
    local display_path="${PWD/$HOME/~}"
    display_path="${display_path#${display_path%/*/*}/}"
    echo -ne "\033]0;${display_path}\007"
}

function get_starship_config() {
	local STARSHIP_DIR="$HOME/.config/starship"

	if [[ "$ROPERDOT_CURRENT_SHELL" = "bash" ]]; then
        if [[ -n "$SSH_CONNECTION" || "$ROPERDOT_SHOW_HOSTNAME" = "true" ]]; then
            echo "$STARSHIP_DIR/starship-bash-server.toml"
        else
            echo "$STARSHIP_DIR/starship-bash.toml"
        fi
        return
    fi

    local scheme="${ROPERDOT_DEFAULT_COMMON_COLOR_SCHEME:-}"

    if [[ "$TERM_PROGRAM" == "Apple_Terminal" ]]; then
   	    if [[ "$scheme" =~ solarized.*light || "$scheme" =~ gruvbox.*light ]]; then
            echo "$STARSHIP_DIR/starship-terminal-light.toml"
        else
            echo "$STARSHIP_DIR/starship-terminal.toml"
        fi
        return
    fi

    if [[ "$scheme" =~ solarized.*light ]]; then
        echo "$STARSHIP_DIR/starship-solarized-light.toml"
    elif [[ "$scheme" =~ gruvbox.*light ]]; then
        echo "$STARSHIP_DIR/starship-gruvbox-light.toml"
    else
        echo "$STARSHIP_DIR/starship.toml"
    fi
}

if [[ "$ROPERDOT_CURRENT_SHELL" = zsh ]]; then
	if [[ "$ROPERDOT_DEFAULT_COMMON_COLOR_SCHEME" =~ solarized.*light || "$ROPERDOT_DEFAULT_COMMON_COLOR_SCHEME" =~ gruvbox.*light ]]; then
		# Light scheme colors
		if [[ "$ROPERDOT_DEFAULT_COMMON_COLOR_SCHEME" =~ solarized.*light ]]; then
		    PROMPT_PANEL_BG_RGB="245;238;219"  # #f5eedb for Solarized Light
		else
		    PROMPT_PANEL_BG_RGB="244;325;201"  # #f4ebc9 for Gruvbox Light
		fi

		PROMPT_PANEL_BG=$(printf '\033[48;2;%sm' "${PROMPT_PANEL_BG_RGB}")
		PROMPT_BLUE_FG=$(printf '\033[%sm' "${COLOR_BLUE_CODE}")
		PROMPT_BRYELLOW_FG=$(printf '\033[%sm' "${COLOR_BRYELLOW_CODE}")
		PROMPT_BLACK_FG=$(printf '\033[%sm' "${COLOR_BLACK_CODE}")
		PROMPT_WHITE_BG=$((COLOR_WHITE_CODE + 10))

		# Combined color codes
		PROMPT_BLUE_ON_PANEL=$(printf '\033[%sm\033[48;2;%sm' "${COLOR_BLUE_CODE}" "${PROMPT_PANEL_BG_RGB}")
		PROMPT_BRYELLOW_ON_PANEL=$(printf '\033[%sm\033[48;2;%sm' "${COLOR_BRYELLOW_CODE}" "${PROMPT_PANEL_BG_RGB}")
		PROMPT_BLUE_ON_WHITE=$(printf '\033[%s;%sm' "${PROMPT_WHITE_BG}" "${COLOR_BLUE_CODE}")
		PROMPT_BLACK_ON_PANEL=$(printf '\033[%sm\033[48;2;%sm' "${COLOR_BLACK_CODE}" "${PROMPT_PANEL_BG_RGB}")

		function set_status_info() {
		    local last_exit=$?
		    if [[ $last_exit -eq 0 ]]; then
		        export STATUS_INFO="${PROMPT_BLUE_ON_PANEL} ✔ ${PROMPT_RESET}"
		    else
		        export STATUS_INFO="${PROMPT_BRYELLOW_ON_PANEL} ${last_exit} ❌ ${PROMPT_RESET}"
		    fi
		}

		function set_dir_stack_info() {
		    local depth=$(dirs -p | wc -l)
		    if [[ $depth -lt 2 ]]; then
		        export DIR_STACK_INFO=""
		        return
		    fi
		    
		    # Build the segment: triangle + content + end symbol
		    export DIR_STACK_INFO="${PROMPT_BLUE_ON_WHITE}${PROMPT_LEFT_TRIANGLE}${PROMPT_BLACK_ON_PANEL} ${depth} ${PROMPT_BLACK_ON_PANEL}${PROMPT_DEPTH_SYMBOL} ${PROMPT_RESET}"
		}
	else
		PROMPT_LEFT_TRIANGLE=$(printf '\uE0B2')  # Left-pointing triangle
		PROMPT_DEPTH_SYMBOL=$(printf '\uF160')

		PROMPT_MAGENTA_BG=$((COLOR_MAGENTA_CODE + 10))
		PROMPT_WHITE_BG=$((COLOR_WHITE_CODE + 10))

		PROMPT_MAGENTA_ON_BLACK=$(printf '\033[%s;%sm' "${PROMPT_BLACK_BG}" "${COLOR_MAGENTA_CODE}")
		PROMPT_BRYELLOW_ON_BLACK=$(printf '\033[%s;%sm' "${PROMPT_BLACK_BG}" "${COLOR_BRYELLOW_CODE}")

		PROMPT_MAGENTA_ON_WHITE=$(printf '\033[%s;%sm' "${PROMPT_WHITE_BG}" "${COLOR_MAGENTA_CODE}")
		PROMPT_BLACK_ON_MAGENTA=$(printf '\033[0;%s;%sm' "${COLOR_BLACK_CODE}" "${PROMPT_MAGENTA_BG}")
		PROMPT_MAGENTA_FG=$(printf '\033[0;%sm' "${COLOR_MAGENTA_CODE}")

		function set_status_info() {
		    local last_exit=$?
		    if [[ $last_exit -eq 0 ]]; then
		        export STATUS_INFO="${PROMPT_MAGENTA_ON_BLACK} ✔ ${PROMPT_RESET}"
		    else
		        export STATUS_INFO="${PROMPT_BRYELLOW_ON_BLACK} ${last_exit} ❌ ${PROMPT_RESET}"
		    fi
		}

		function set_dir_stack_info() {
		    local depth=$(dirs -p | wc -l)
		    if [[ $depth -lt 2 ]]; then
		        export DIR_STACK_INFO=""
		        return
		    fi
		    
		    # Build the segment: triangle + content + end symbol
		    export DIR_STACK_INFO="${PROMPT_MAGENTA_ON_WHITE}${PROMPT_LEFT_TRIANGLE}${PROMPT_BLACK_ON_MAGENTA} ${depth} ${PROMPT_BLACK_ON_MAGENTA}${PROMPT_DEPTH_SYMBOL} ${PROMPT_RESET}"
		}
	fi

	export STARSHIP_CONFIG="$(get_starship_config)"
	if command -v starship >/dev/null 2>&1; then
	    precmd() {
	    	# apply_scheme
			set_terminal_title
	        set_status_info
	        set +F
	        set_git_info
	        set_dir_stack_info
	    }
	    eval "$(starship init zsh)"
	else
	    precmd() {
	    	set_terminal_title
	        set +F
	    }
	fi
else
	# bash
    if [[ ! "$PROMPT_COMMAND" =~ store_history ]]; then
        export PROMPT_COMMAND="set_terminal_title; store_history; set +f"
    fi
    
    if command -v starship >/dev/null 2>&1; then
	   	export STARSHIP_CONFIG="$(get_starship_config)"
        eval "$(starship init bash)"
        export PROMPT_COMMAND="set_git_info; ${PROMPT_COMMAND}"
    fi
fi

do_timing "phase 11"

if [[ -d ~/.nvm ]]; then
	export NVM_DIR="$HOME/.nvm"
#	[[ -s "$NVM_DIR/nvm.sh" ]] && source "$NVM_DIR/nvm.sh" --no-use
	[[ -s "$NVM_DIR/nvm.sh" ]] && source "$NVM_DIR/nvm.sh"
	[[ "$ROPERDOT_CURRENT_SHELL" = bash && -s "$NVM_DIR/bash_completion" ]] && source "$NVM_DIR/bash_completion"
fi

# SDKMAN initialization
if [[ -d ~/.sdkman ]]; then
    export SDKMAN_DIR="$HOME/.sdkman"
    [[ -s "$SDKMAN_DIR/bin/sdkman-init.sh" ]] && source "$SDKMAN_DIR/bin/sdkman-init.sh"
fi

# Oracle Instant Client environment (find any installed version)
for oracle_dir in /opt/oracle/instantclient_*; do
    if [[ -d "$oracle_dir" ]]; then
        export ORACLE_HOME="$oracle_dir"
        export LD_LIBRARY_PATH="$ORACLE_HOME:$LD_LIBRARY_PATH"
        export DYLD_LIBRARY_PATH="$ORACLE_HOME:$DYLD_LIBRARY_PATH"
        export PATH="$ORACLE_HOME:$PATH"
        break
    fi
done
unset oracle_dir

# .NET environment
if command -v dotnet >/dev/null 2>&1; then
    export PATH="$HOME/.dotnet/tools:$PATH"
fi

# Liquibase
[[ -d /opt/liquibase ]] && export PATH="$PATH:/opt/liquibase"

if [[ -f /etc/ssl/certs/ca-certificates.crt ]]; then
    export NODE_EXTRA_CA_CERTS=/etc/ssl/certs/ca-certificates.crt
    export REQUESTS_CA_BUNDLE=/etc/ssl/certs/ca-certificates.crt
    export SSL_CERT_FILE=/etc/ssl/certs/ca-certificates.crt
fi

do_timing

# Create symlinks in roperdot/extra-bin for scripts in roperdot/bin
#while IFS= read f; do
#	name="$(basename "$f")"
#	name="${name%%.p[ly]}"
#	[[ -e "${ROPERDOT_DIR}/extra-bin/$name" ]] || ln -s "$f" "${ROPERDOT_DIR}/extra-bin/$name"
#done < <(find "${ROPERDOT_DIR}/bin" -name "*.pl" -o -name "*.py")

# This should be done here instead of during installs so that executables like z will be defined
if [[ ! -f ~/roperdot-help.txt ]]; then
	echo "Building roperdot help file"
	. "${ROPERDOT_DIR}/bin/generate-help"
fi

if [[ -n "$ROPERDOT_DOT_IN_PATH" ]]; then
	export PATH=".:$PATH"
else
	export PATH
fi
