#
# Description: Bootstrap script for roperdot dotfiles
#
# Author: Andy Roper <andyroper42@gmail.com>
# URL: https://github.com/andy-roper/roperdot
#

# Files that are part of this package:
# roperdot-bootstrap: this file
# .aliases: aliases not specific to an OS
# .functions: functions not specific to an OS
# .roperdot-os-<os>: OS-specific bash configs
# install.sh: roperdot install script
# install-apps: script for installing necessary/useful apps to use with this package
# roperdot-setup.txt: package setup document
# *-shell-apps.json: shell application definitions by OS
# *-gui-apps.json: GUI application definitions by OS
# source-scripts: scripts to be sourced
# app-bin-bash: application-calling scripts for bash; generated by update-app-binaries
# app-bin-zsh: application-calling scripts for zsh; generated by update-app-binaries
# bin: sh, JavaScript and Perl scripts
# bin-scripts: shell script source
# bin-scripts/<os>: shell scripts for a specific OS
# bin-bash: copies of scripts in bin-scripts with a bash shebang
# bin-zsh: copies of scripts in bin-scripts with a zsh shebang
# config/apps: configuration files for applications
# config/color-schemes: color scheme files for applications
# extra-bin: binaries for installed applications
# install-profiles: installation profiles
#
#
# Files created during install:
# ~/roperdot-loader: loader script with user-specific settings
# ~/.roperdot-os-functions: generated file containing OS-specific functions based on installed apps
# ~/.extra: personal aliases/functions/variables that you define
#
# Environment Variables:
# ROPERDOT_OS_NAME: Name of OS. Supported values are ubuntu, centos and darwin.
# ROPERDOT_OS_ENV: OS and environment. Supported values are ubuntu, kubuntu, centos, centos-gnome, rhel, darwin, raspbian
# ROPERDOT_DESKTOP_ENV: Supported values are gnome, kde, windows and mac
# ROPERDOT_OVERRIDE_PROMPT: true if using the prompt defined in this file
# ROPERDOT_PROMPT_LINES: number of lines to show in the bash prompt, 1 or 2
# ROPERDOT_HISTORY_BY_SESSION: true if each terminal session has its own history file
# ROPERDOT_COLOR_SCHEME: color scheme to use
# ROPERDOT_DEFAULT_COMMON_COLOR_SCHEME: color scheme to use if ROPERDOT_COMMON_COLOR_SCHEME is set to default
# ROPERDOT_COMMON_COLOR_SCHEME: color scheme to use for pygmentize
# ROPERDOT_ARC_TYPE: default archive type when creating archives using the c script
# EDITOR: default editor
# 
# If you want to associate a new application with an edit/view function, make the necessary updates to
# bin/update-app-binaries in the roperdot directory and run it. This will regenerate ~/.roperdot-os-functions
# and the binaries in ~/roperdot/app-bin-bash and ~/roperdot/app-bin-zsh.

# TO DO
# Maybe look into having a script to run to toggle using default prompt or custom prompt

# If not running interactively, don't do anything
[[ $- == *i* ]] || return

if [[ -z "$ROPERDOT_SUPPRESS_INFO" && -e ~/roperdot-info.txt ]]; then
	echo -e "Set ROPERDOT_SUPPRESS_INFO to true in ~/roperdot-loader to stop seeing these messages.\n"
	cat ~/roperdot-info.txt
fi

if [[ -n "$BASH_VERSION" ]]; then
	export ROPERDOT_CURRENT_SHELL=bash
	ROPERDOT_SHELL_VERSION="$(bash --version | awk -F"version " '{print $2;exit;}')"
	export ROPERDOT_SHELL_VERSION="${ROPERDOT_SHELL_VERSION%%.*}"
	export ROPERDOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
elif [[ -n "$ZSH_VERSION" ]]; then
	export ROPERDOT_CURRENT_SHELL=zsh
	ROPERDOT_SHELL_VERSION="$(zsh --version)"
	ROPERDOT_SHELL_VERSION="${ROPERDOT_SHELL_VERSION#zsh }"
	export ROPERDOT_SHELL_VERSION="${ROPERDOT_SHELL_VERSION%%.*}"
	export ROPERDOT_DIR="$(cd "$(dirname "${(%):-%N}")" && pwd)"
fi

#SHOW_TIMING=true
source "${ROPERDOT_DIR}/source-scripts/do-timing"
do_timing "phase 1a"

#export LOCALUSR="${ROPERDOT_DIR}/local-usr"
export LOCAL=~/.local
export LOCALUSR=$LOCAL/usr
[[ -d "${LOCALUSR}/bin" ]] || mkdir -p "${LOCALUSR}/bin"
[[ -d "${ROPERDOT_DIR}/extra-bin" ]] || mkdir "${ROPERDOT_DIR}/extra-bin"

do_timing "phase 1b"
source "${ROPERDOT_DIR}/source-scripts/detect-os"

# Update module_path if in zsh and using local Homebrew install
if [[ "$ROPERDOT_CURRENT_SHELL" = zsh && -d ~/homebrew/lib/zsh ]]; then
    module_path=(~/homebrew/lib/zsh $module_path)
fi

do_timing "phase 1c"
if [[ -f "$ROPERDOT_DIR/VERSION" ]]; then
    CURRENT_VERSION=$(cat "$ROPERDOT_DIR/VERSION" 2>/dev/null | tr -d '\n\r ')
else
    CURRENT_VERSION=""
fi
if [[ "$CURRENT_VERSION" != "$ROPERDOT_VERSION" ]] || [[ -z "$CURRENT_VERSION" ]]; then
	echo "Copying scripts to ${ROPERDOT_DIR}/bin-${ROPERDOT_CURRENT_SHELL}"
	ROPERDOT_SHELL_TO_COPY=$ROPERDOT_CURRENT_SHELL
	source "${ROPERDOT_DIR}/source-scripts/copy-scripts"
	unset ROPERDOT_SHELL_TO_COPY
    sed -i.bak "s/^export ROPERDOT_VERSION=.*/export ROPERDOT_VERSION=$CURRENT_VERSION/" ~/roperdot-loader
fi

do_timing "phase 1d"
if [[ -n $ROPERDOT_DESKTOP_ENV && ! -e "${ROPERDOT_DIR}/app-bin-${ROPERDOT_CURRENT_SHELL}/text-editor-app" ]]; then
	echo "Copying scripts to ${ROPERDOT_DIR}/app-bin-${ROPERDOT_CURRENT_SHELL}"
	[[ $ROPERDOT_CURRENT_SHELL = bash ]] && export PROCESSING_BASH=true || export PROCESSING_ZSH=true
	"${ROPERDOT_DIR}/bin-${ROPERDOT_CURRENT_SHELL}/update-app-binaries"
	[[ $ROPERDOT_CURRENT_SHELL = bash ]] && unset PROCESSING_BASH || unset PROCESSING_ZSH
fi
do_timing "phase 1e"
source "${ROPERDOT_DIR}/source-scripts/re-match"
do_timing "phase 1f"
source "${ROPERDOT_DIR}/source-scripts/realpath"
do_timing "phase 1g"
source "${ROPERDOT_DIR}/source-scripts/abs-path"
do_timing "phase 1h"
[[ -n "$ROPERDOT_USE_VIM_SETTINGS" ]] && . "${ROPERDOT_DIR}/source-scripts/check-vi"
do_timing "phase 1i"
[[ -d ~/homebrew ]] && eval "$(~/homebrew/bin/brew shellenv)"
# Do this after the homebrew evaluation to ensure roperdot bin directories precede homebrew directories
PATH="${ROPERDOT_DIR}/bin-${ROPERDOT_CURRENT_SHELL}:${ROPERDOT_DIR}/bin:$PATH"
[[ -f "${ROPERDOT_DIR}/.roperdot-os-${ROPERDOT_OS_NAME}" ]] && source "${ROPERDOT_DIR}/.roperdot-os-${ROPERDOT_OS_NAME}"

# Implemented to work around Python externally-managed-environment errors
current_python="$(command -v python3)"
if [[ -f /usr/bin/python3 ]] && [[ "$current_python" == "/usr/local/bin/python3" || "$current_python" == */homebrew/bin/python3 ]] && [[ ! -f "${ROPERDOT_DIR}/extra-bin/python3" ]]; then
	[[ -d "${ROPERDOT_DIR}/extra-bin" ]] || mkdir "${ROPERDOT_DIR}/extra-bin"
    ln -sf /usr/bin/python3 "${ROPERDOT_DIR}/extra-bin/python3"
    ln -sf /usr/bin/pip3 "${ROPERDOT_DIR}/extra-bin/pip3"
fi

#time_event() {
#	[[ -z "$debugging" || -z "$start_time" ]] && return
#	[[ -n "$1" ]] && echo "$1: $(( ($(date +%s%N) - start_time) / 1000000)) ms"
#	start_time=$(date +%s%N)
#}

[[ -z "$MANPATH" ]] && MANPATH="$(manpath)"

do_timing "phase 2a"

[[ -d "${LOCAL}/bin" ]] && PATH="${LOCAL}/bin:$PATH"
[[ -d "${LOCALUSR}/bin" ]] && PATH="${LOCALUSR}/bin:$PATH"
re=/usr/local/bin
# For Perl-compatible regexes to work with brew-installed zsh on Mac, /usr/local/bin must precede /usr/bin in PATH
# [[ -d "/usr/local/bin" && ! "$PATH" =~ $re ]] && PATH="$PATH:/usr/local/bin"
[[ -d "/usr/local/bin" && ! "$PATH" =~ $re ]] && PATH="/usr/local/bin:$PATH"

# Simplified legacy Python block on 8/25/2025
#if ! command -v python >/dev/null 2>&1; then
#	PYBIN=$(command -v python3)
#	[[ -z "$PYBIN" ]] && PYBIN=$(command -v python2)
#	if [[ -n "$PYBIN" ]]; then
#		echo "Creating python symlink for $PYBIN"
#		BINPATH="${PYBIN%/*}"
#		sudo ln -s "$PYBIN" "$BINPATH/python"
#		unset PYBIN BINPATH
#	fi
#fi
#if [[ -d "$LOCALUSR/lib" ]]; then
#	local_python_dir="$(find "$LOCALUSR/lib" -name "python*" 2>/dev/null)"
#	if [[ -n "$local_python_dir" ]]; then
#		if [[ -n "$PYTHONPATH" ]]; then
#			export PYTHONPATH="$PYTHONPATH:$local_python_dir/site-packages"
#		else
#			export PYTHONPATH="$local_python_dir/site-packages"
#		fi
#	fi
#fi
#if [[ -d ~/Library/Python ]]; then
#	if command -v python3 >/dev/null 2>&1; then
#		re_match "$(python3 --version)" ' ([0-9]+\.[0-9]+)'
#	else
#		re_match "$(python --version)" ' ([0-9]+\.[0-9]+)'
#	fi
#	ver="${re_match[1]}"
#	if [[ -n $ver ]]; then
#		spd=~/Library/Python/$ver/lib/python/site-packages
#		if [[ -d $spd ]]; then
#			if [[ -n "$PYTHONPATH" ]]; then
#				export PYTHONPATH="$PYTHONPATH:$spd"
#			else
#				export PYTHONPATH="$spd"
#			fi
#		fi
#	fi
#fi
#if [[ "$ROPERDOT_OS_TYPE" = mac ]]; then
#	if command -v python3 >/dev/null 2>&1; then
#		re_match "$(python3 --version)" ' ([0-9]+\.[0-9]+)'
#	else
#		re_match "$(python --version)" ' ([0-9]+\.[0-9]+)'
#	fi
#	ver="${re_match[1]}"
#	if [[ -n "$ver" ]]; then
#		spd=~/".local/lib/python${ver}/site-packages"
#		if [[ -d $spd ]]; then
#			if [[ -n "$PYTHONPATH" ]]; then
#				export PYTHONPATH="$PYTHONPATH:$spd"
#			else
#				export PYTHONPATH="$spd"
#			fi
#		fi
#	fi
#fi
if ! command -v python >/dev/null 2>&1 && [[ -f /usr/bin/python3 ]]; then
    ln -sf /usr/bin/python3 "${ROPERDOT_DIR}/extra-bin/python"
fi

do_timing "phase 2b"
# if command -v npm >/dev/null 2>&1 && [[ ! "$PATH" =~ npm ]]; then
# 	npmdir="$(npm bin -g 2>/dev/null)"
# 	if [[ "$ROPERDOT_DESKTOP_ENV" = windows && "$ROPERDOT_OS_ENV" = ubuntu ]]; then
# 		d="$(wslpath "$npmdir" 2>&1)"
# 		[[ -n "$d" ]] && npmdir="$d"
# 	fi
# 	PATH="$PATH:$npmdir"
# fi

do_timing "phase 2c"
if [[ -d ~/.npm-packages ]]; then
	export NPM_PACKAGES="${HOME}/.npm-packages"
	PATH="$NPM_PACKAGES/bin:$PATH"
	[[ -d "$NPM_PACKAGES/share/man" ]] && MANPATH="$NPM_PACKAGES/share/man:$MANPATH"
fi
export INPUTRC="${ROPERDOT_DIR}/.inputrc"

[[ -d "${ROPERDOT_DIR}/os-bin/${ROPERDOT_OS_TYPE}" ]] && PATH="${ROPERDOT_DIR}/os-bin/${ROPERDOT_OS_TYPE}:$PATH"
[[ -d "${ROPERDOT_DIR}/extra-bin" ]] && PATH="${ROPERDOT_DIR}/extra-bin:$PATH"
[[ $ROPERDOT_CURRENT_SHELL == bash && -d "${ROPERDOT_DIR}/app-bin-bash" ]] && PATH="${ROPERDOT_DIR}/app-bin-bash:$PATH"
[[ $ROPERDOT_CURRENT_SHELL == zsh && -d "${ROPERDOT_DIR}/app-bin-zsh" ]] && PATH="${ROPERDOT_DIR}/app-bin-zsh:$PATH"

[[ -d "${LOCALUSR}/share/man" ]] && MANPATH="${MANPATH}:${LOCALUSR}/share/man"
[[ -d "${LOCALUSR}/man" ]] && MANPATH="${MANPATH}:${LOCALUSR}/man"
[[ -d "${LOCAL}/man" ]] && MANPATH="${MANPATH}:${LOCAL}/man"
[[ -d "${LOCAL}/share/man" ]] && MANPATH="${MANPATH}:${LOCAL}/share/man"
[[ -d "${ROPERDOT_DIR}/man" ]] && MANPATH="${MANPATH}:${ROPERDOT_DIR}/man"
export MANPATH

do_timing "phase 3"

if [[ "$ROPERDOT_USE_VIM_SETTINGS" = true ]]; then
	[[ -d ~/.vim/backup ]] || mkdir ~/.vim/backup
	[[ -d ~/.vim/swap ]] || mkdir ~/.vim/swap
	[[ -d ~/.vim/undo ]] || mkdir ~/.vim/undo
	if [[ -e ~/.vimrc-roperdot ]]; then
		[[ -e ~/.vimrc ]] && \mv ~/.vimrc ~/.vimrc.bak
		\cp ~/.vimrc-roperdot ~/.vimrc
	fi
	[[ -d "${ROPERDOT_DIR}/neovim-runtime" ]] && export VIM="${ROPERDOT_DIR}/neovim-runtime"
	[[ -e ~/.vi-plugin-init ]] && . ~/.vi-plugin-init
fi

# Fix brew "parent directory is world writable but not sticky" error in WSL
[[ "$ROPERDOT_OS_ENV" = "ubuntu" && "$ROPERDOT_DESKTOP_ENV" = "windows" ]] && umask 022

# autoload must execute before .functions is sourced so it runs before compdef executions
if [[ "$ROPERDOT_CURRENT_SHELL" = zsh ]]; then
	# Auto-fix insecure directory permissions before compinit
	if ! compaudit >/dev/null 2>&1; then
		# compaudit found issues, try to fix them automatically
		compaudit 2>/dev/null | xargs chmod g-w,o-w 2>/dev/null || true
	fi

	# Initialize the completion system
	autoload -Uz compinit && compinit
	error_code=$?
	if [[ $error_code -ne 0 && "$ROPERDOT_OS_ENV" = "darwin" ]]; then
		read "?Error detected starting compinit. Fix by changing permissions on /usr/local/share [y/n]? "
		if [[ "$REPLY" = y ]]; then
			chmod -R go-w /usr/local/share
			autoload -Uz compinit && compinit
		fi
	fi
	[[ -e "$ROPERDOT_DIR/.zsh-suffix-aliases" ]] && . "$ROPERDOT_DIR/.zsh-suffix-aliases"
fi

do_timing "phase 4"
[[ -f "${ROPERDOT_DIR}/.aliases" ]] && source "${ROPERDOT_DIR}/.aliases"
do_timing "phase 5"
[[ -f "${ROPERDOT_DIR}/.functions" ]] && source "${ROPERDOT_DIR}/.functions"
do_timing "phase 6"

set +f

[[ -f ~/.extra ]] && source ~/.extra
[[ -f "${ROPERDOT_DIR}/.extra" ]] && source "${ROPERDOT_DIR}/.extra"
[[ -f "${ROPERDOT_DIR}/.cross-platform" ]] && source "${ROPERDOT_DIR}/.cross-platform"
[[ -f ~/.roperdot-os-functions ]] && source ~/.roperdot-os-functions
do_timing "phase 7"

#for file in ~/extra-source/*; do
#	[[ -f "$file" ]] && source "$file"
#done
#unset file

if command -v brew >/dev/null 2>&1 && zpath="$(brew --prefix)/etc/profile.d/z.sh" && [[ -e "$zpath" ]];	then
	source "$zpath"
elif [[ -e "${ROPERDOT_DIR}/extra-bin/z.sh" ]]; then
	source "${ROPERDOT_DIR}/extra-bin/z.sh"
fi

# Export _z to subshells if it's defined
# command -v _z >/dev/null 2>&1 && export -f _z

# Update values of LINES and COLUMNS after the window is sized
[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && shopt -s checkwinsize
export COLUMNS

# Enable autocompletion of directories; treat a directory name as a cd command
if [[ "$ROPERDOT_CURRENT_SHELL" = bash ]]; then
	[[ "$ROPERDOT_SHELL_VERSION" -gt 3 ]] && shopt -s autocd 2> /dev/null
else
	setopt autocd
fi

# make less more friendly for non-text input files, see lesspipe(1)
# command -v lesspipe >/dev/null 2>&1 && eval "$(SHELL=/bin/sh lesspipe)"

[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && trap 'export bash_command=$BASH_COMMAND' DEBUG

# Don't clear the screen after quitting a manual page
export MANPAGER="less -X"

# Prefer US English and use UTF-8
# Set locale with fallback
if locale -a 2>/dev/null | grep -qi -E "en_US\.utf-?8"; then
    export LC_ALL="en_US.UTF-8"
    export LANG="en_US.UTF-8"
elif locale -a 2>/dev/null | grep -qi -E "C\.utf-?8"; then
    export LC_ALL="C.UTF-8"
    export LANG="C.UTF-8"
else
    # Don't set LC_ALL, just use basic LANG
    export LANG="C"
fi

if [[ -d /home/linuxbrew/.linuxbrew/bin ]]; then
	export PATH="$PATH:/home/linuxbrew/.linuxbrew/bin"
	export MANPATH="$MANPATH:/home/linuxbrew/.linuxbrew/share/man"
	export INFOPATH="$INFOPATH:/home/linuxbrew/.linuxbrew/share/info"
fi

if [[ -f "${LOCALUSR}/bin/mc" ]]; then
	if [[ -n "$LD_LIBRARY_PATH" ]]; then
		export LD_LIBRARY_PATH="${LD_LIBRARY_PATH}:${LOCALUSR}/lib/x86_64-linux-gnu"
	else
		export LD_LIBRARY_PATH="${LOCALUSR}/lib/x86_64-linux-gnu"
	fi
	export MC_DATADIR="${LOCALUSR}/share/mc"
fi

if command -v fzf >/dev/null 2>&1; then
	if [[ "$ROPERDOT_OS_NAME" = ubuntu ]] && command -v fdfind >/dev/null 2>&1; then
		have_fd=true
	elif command -v fd >/dev/null 2>&1; then
		have_fd=true
	fi
	if [[ -n "$have_fd" ]]; then
		export R_DEFAULT_COMMAND='fd --type file --follow --hidden --exclude .git'
		export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
		export FZF_DEFAULT_OPTS="--extended"
	fi
fi

# ------------------------------------------------------------------------------------

# History-related

do_timing "phase 8"

if [[ "$ROPERDOT_CURRENT_SHELL" = bash ]]; then
    if [[ -z "$_fzf_completion_loader" ]]; then
        [[ -e ~/.fzf.bash ]] && . ~/.fzf.bash
    fi
elif [[ "$ROPERDOT_CURRENT_SHELL" = zsh ]]; then
    if [[ -z "$fzf_default_completion" ]]; then
        [[ -e ~/.fzf.zsh ]] && . ~/.fzf.zsh
    fi
fi

if [[ -n "$ROPERDOT_HISTORY_BY_SESSION" ]]; then
	store_history () {
		history -a
	}
else
	store_history () {
		history -a
		history -c
		history -r
	}
fi

# 1 Jan 2019: wrapped ROPERDOT_PROMPT_COMMAND code in check for store_history to avoid repeating commands if the bootstrap is
# sourced multiple times
if [[ "$ROPERDOT_CURRENT_SHELL" = bash ]]; then
	if [[ ! "$ROPERDOT_PROMPT_COMMAND" =~ store_history ]]; then
		if [[ "$ROPERDOT_OS_ENV" = "darwin" ]]; then
			title () {
				echo -ne "\033]0;$@\007"
			}
#			if [[ "$ROPERDOT_SHOW_GIT_PROMPT_INFO" = "true" ]]; then
#				export ROPERDOT_PROMPT_COMMAND="${ROPERDOT_PROMPT_COMMAND:+$ROPERDOT_PROMPT_COMMAND$'\n'}title ${USER}@${HOSTNAME%%.*};prompt_git;store_history;apply_scheme;set +f"
#			else
#				export ROPERDOT_PROMPT_COMMAND="${ROPERDOT_PROMPT_COMMAND:+$ROPERDOT_PROMPT_COMMAND$'\n'}title ${USER}@${HOSTNAME%%.*};store_history;apply_scheme;set +f"
#			fi
			if [[ "$ROPERDOT_SHOW_GIT_PROMPT_INFO" = "true" ]]; then
				export ROPERDOT_PROMPT_COMMAND="${ROPERDOT_PROMPT_COMMAND:+$ROPERDOT_PROMPT_COMMAND$'\n'}title ${USER}@${HOSTNAME%%.*};prompt_git;store_history;set +f"
			else
				export ROPERDOT_PROMPT_COMMAND="${ROPERDOT_PROMPT_COMMAND:+$ROPERDOT_PROMPT_COMMAND$'\n'}title ${USER}@${HOSTNAME%%.*};store_history;set +f"
			fi
		else
#			if [[ "$ROPERDOT_SHOW_GIT_PROMPT_INFO" = "true" ]]; then
#				export ROPERDOT_PROMPT_COMMAND="${ROPERDOT_PROMPT_COMMAND:+$ROPERDOT_PROMPT_COMMAND$'\n'}prompt_git;store_history;apply_scheme;set +f"
#			else
#				export ROPERDOT_PROMPT_COMMAND="${ROPERDOT_PROMPT_COMMAND:+$ROPERDOT_PROMPT_COMMAND$'\n'}store_history;apply_scheme;set +f"
#			fi
			if [[ "$ROPERDOT_SHOW_GIT_PROMPT_INFO" = "true" ]]; then
				export ROPERDOT_PROMPT_COMMAND="${ROPERDOT_PROMPT_COMMAND:+$ROPERDOT_PROMPT_COMMAND$'\n'}prompt_git;store_history;set +f"
			else
				export ROPERDOT_PROMPT_COMMAND="${ROPERDOT_PROMPT_COMMAND:+$ROPERDOT_PROMPT_COMMAND$'\n'}store_history;set +f"
			fi
			# To make available in history the most recently executed command in another terminal session, just press
			# Enter to issue a null command
		fi
	fi
fi

if [[ -n "$ROPERDOT_HISTORY_BY_SESSION" ]]; then
	export HISTSIZE=2000
	export HISTFILESIZE=2000
	# Define history file with PID as extension
	export HISTFILE=$HOME/.bash_history.$$
	# Delete history files for inactive sessions
	while IFS= read -r -d '' hf; do
#		if [[ "$hf" =~ \.([0-9]+)$ ]]; then
#			pid=${BASH_REMATCH[1]}
		if re_match "$hf" "\.([0-9]+)$" ]]; then
			pid="${re_match[1]}"
			ps | grep "$pid.*[b]ash" >/dev/null || \rm "$hf"
		fi
	done < <(find ~ -maxdepth 1 -name ".bash_history.*" -print0)
	# Delete history file on shell exit
	trap '\rm -f "$HISTFILE"' 0
else
	export HISTSIZE=100000
	export HISTFILESIZE=$HISTSIZE
	[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && shopt -s histappend
fi

# Enable history expansion with space
# Typing !!<space> will replace the !! with your last command
[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && bind Space:magic-space

# Use standard ISO 8601 timestamp
# %F equivalent to %Y-%m-%d
# %T equivalent to %H:%M:%S (24-hour format)
export HISTTIMEFORMAT='%F %T '

# Don't record some commands
export HISTIGNORE="&:[ ]*:exit:ls:bg:fg:history:clear:cls"

# don't include spaces in history
export HISTCONTROL=ignorespace

# Save multi-line commands as one command
[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && shopt -s cmdhist

# ------------------------------------------------------------------------------------

# Colors and prompt

do_timing "phase 9a"

if [[ "$COLORTERM" = gnome-* && "$TERM" = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
    export TERM=gnome-256color
elif infocmp xterm-256color >/dev/null 2>&1; then
    export TERM=xterm-256color
fi

if [[ "$ROPERDOT_OS_ENV" = "darwin" && "$TERM_PROGRAM" == "Apple_Terminal" ]]; then
    export STARSHIP_CONFIG="$HOME/.config/starship/starship-terminal.toml"
    export TERM=xterm-256color # Force 256-color mode for other apps too
    unset COLORTERM  # Don't advertise 24-bit support
    # Vim: Use 256-color compatible colorscheme
    export VIM_COLOR_MODE="256color"
else
	export STARSHIP_CONFIG="$HOME/.config/starship/starship.toml"
fi

do_timing "phase 9b"
#if [[ -n "$ROPERDOT_COLOR_SCHEME" ]]; then
#	if command -v tput >/dev/null 2>&1 && tput setaf 1 >/dev/null 2>&1; then
#		# 256 colors
#		source "${ROPERDOT_DIR}/.define_colors.${ROPERDOT_COLOR_SCHEME}.256"
#	else
#		# 16 colors
#		source "${ROPERDOT_DIR}/.define_colors.16-color"
#	fi
#fi

do_timing "phase 9c"
export CLICOLOR=1
[[ "$ROPERDOT_OS_ENV" = "darwin" ]] && export CLICOLOR_FORCE=1

do_timing "phase 9d"
initialize_colors

do_timing "phase 9e"
[[ "$ROPERDOT_CURRENT_SHELL" = bash && -e "${ROPERDOT_DIR}/.bash_prompt" ]] && source "${ROPERDOT_DIR}/.bash_prompt"

# export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

do_timing "phase 9f"
# Moved setting LESS_TERMCAP env vars to man function

export LESS='-MR'

do_timing "phase 9g"
if command -v pygmentize >/dev/null 2>&1; then
#	command -v tput >/dev/null 2>&1 && tput setaf 1 >/dev/null 2>&1 && colors=256 || colors=16
#	lessfilter="${ROPERDOT_DIR}/lessfilter-${colors}-${ROPERDOT_CURRENT_SHELL}"
	lessfilter="${ROPERDOT_DIR}/bin-${ROPERDOT_CURRENT_SHELL}/lessfilter"
	export LESSOPEN="|\"$lessfilter\" %s"
	[[ -e "$lessfilter" && ! -x "$lessfilter" ]] && chmod u+x "$lessfilter"
	unset colors lessfilter
fi

# ------------------------------------------------------------------------------------

# Completion

do_timing "phase 10"

# Enable extended pattern matching
[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && shopt -s extglob || setopt ksh_glob

# Case-insensitive globbing (used in pathname expansion)
if [[ "$ROPERDOT_CURRENT_SHELL" = bash ]]; then
	shopt -s nocaseglob
else
	unsetopt case_glob
	# Do case-insensitive tab completion in zsh
	zstyle ':completion:*' matcher-list 'm:{[:lower:][:upper:]}={[:upper:][:lower:]}' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*'
fi

# Autocorrect for arguments supplied to cd and for directory names to match a glob
#if [[ "$ROPERDOT_CURRENT_SHELL" = bash ]]; then
#	shopt -s cdspell dirspell 2>/dev/null
#else
#	setopt correct correct_all
#fi

# Turn on recursive globbing (enables ** to recurse all directories)
[[ "$ROPERDOT_CURRENT_SHELL" = bash ]] && shopt -s globstar 2> /dev/null

# Eliminate "No match found" message when globbing doesn't match
[[ "$ROPERDOT_CURRENT_SHELL" = zsh ]] && setopt +o nomatch

# bash_completion is sourced for macOS in its .roperdot-os file

# Enable tab completion for "g" by marking it as an alias for "git"
command -v __git_complete >/dev/null 2>&1 && __git_complete g __git_main

# Fix broken links to configuration files
#if [[ -L "/usr/local/bin/grcat" && ! -e "/usr/local/bin/grcat" ]]; then
#	echo "Fixing link for /usr/local/bin/grcat"
#	ln -sf "${ROPERDOT_DIR}/extra-bin/grcat" /usr/local/bin/grcat
#fi

# fix-link ".dircolors"
# link_files=(".git_colors" ".gitconfig" ".gitconfig.local" ".gitignore")
link_files=(".gitconfig" ".gitconfig.local" ".gitignore")
for link_file in "${link_files[@]}"; do
	if fix-link "$link_file" true; then
		admin_link_failure=true
		break
	fi
done

if [[ "$ROPERDOT_CURRENT_SHELL" = zsh ]]; then
	# File completion (can match files in subdirectories)
	compdef '_files' chmox d2u decrypt e encrypt fs la lsd modtime sha1 sha1bin sha256 sha256bin v vb vt

	# Directory completion
	compdef '_directories' fm cpp cpr

	# Archive file completion
	compdef '_files -g "*.zip" -g "*.7z" -g "*.rar" -g "*.tar" -g "*.tar.gz" -g "*.tgz" -g "*.cbr" -g "*.cbz"' x xd

	# Directory and archive completion
	compdef '_files -/ -g "*.zip" -g "*.7z" -g "*.rar" -g "*.tar" -g "*.tar.gz" -g "*.tgz" -g "*.cbr" -g "*.cbz" -g "*.dmg" -g "*.iso"' cd

	# JSON file completion
	compdef '_files -g "*.json"' format-json-file

	# format-specific completion
	compdef '_files -g "*.sql" -g "*.json" -g "*.js" -g "*.html" -g "*.css"' format

	# Define functions needed by Starship prompt

	function set_git_info() {
	    if ! git rev-parse --git-dir >/dev/null 2>&1; then
	    	export GIT_STATUS_INFO=""
	    	return
	    fi

        local branch=$(git branch --show-current 2>/dev/null)
        
        # Single git command for all local status
        local status_output=$(git status --porcelain 2>/dev/null)
        
        # Parse status counts efficiently
        local staged=0 unstaged=0 untracked=0 conflicted=0
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            local index_status="${line:0:1}"
            local work_tree_status="${line:1:1}"
            
            # Count status types
            [[ "$index_status" != " " && "$index_status" != "?" ]] && ((staged++))
            [[ "$work_tree_status" != " " && "$work_tree_status" != "?" ]] && ((unstaged++))
            [[ "$index_status" == "?" ]] && ((untracked++))
            [[ "$index_status" == "U" || "$work_tree_status" == "U" || "$index_status" == "A" && "$work_tree_status" == "A" ]] && ((conflicted++))
        done <<< "$status_output"
        
        # Get ahead/behind counts (only if upstream exists)
        local ahead=0 behind=0
        if git rev-parse --verify @{upstream} >/dev/null 2>&1; then
            local ahead_behind=$(git rev-list --count --left-right @{upstream}...HEAD 2>/dev/null)
            behind=${ahead_behind%	*}
            ahead=${ahead_behind#*	}
        fi
        
        # Get stash count efficiently
        local stashes=0
        if git rev-parse --verify refs/stash >/dev/null 2>&1; then
            stashes=$(git rev-list --walk-reflogs --count refs/stash 2>/dev/null || echo 0)
        fi
        
        # Build status string
        local status_indicators=""
        [[ $staged -gt 0 ]] && status_indicators+=" +$staged"
        [[ $unstaged -gt 0 ]] && status_indicators+=" !$unstaged"
        [[ $untracked -gt 0 ]] && status_indicators+=" ?$untracked"
        [[ $conflicted -gt 0 ]] && status_indicators+=" ~$conflicted"
        [[ $ahead -gt 0 ]] && status_indicators+=" ⇡$ahead"
        [[ $behind -gt 0 ]] && status_indicators+=" ⇣$behind"
        [[ $stashes -gt 0 ]] && status_indicators+=" *$stashes"
        
        local reset=$(printf '\033[0m')
        local triangle=$(printf '\uE0B0')
        
        # Determine if repo is clean
        if [[ $staged -eq 0 && $unstaged -eq 0 && $untracked -eq 0 && $conflicted -eq 0 ]]; then
            # Clean - but show ahead/behind and stashes if they exist
	        local green_fg=$(printf '\033[0;%sm' "${COLOR_GREEN_CODE}")
	        local green_bg=$((COLOR_GREEN_CODE + 10))
	        local black_on_green=$(printf '\033[0;%s;%sm' "${COLOR_BLACK_CODE}" "${green_bg}")
            local clean_indicators=""
            [[ $ahead -gt 0 ]] && clean_indicators+=" ⇡$ahead"
            [[ $behind -gt 0 ]] && clean_indicators+=" ⇣$behind"
            [[ $stashes -gt 0 ]] && clean_indicators+=" *$stashes"
   	        if [[ "$TERM_PROGRAM" == "Apple_Terminal" ]]; then
	        	local initial_triangle_color=$(printf '\033[%s;%sm' "${green_bg}" "${COLOR_BLACK_CODE}")
	        	local green_on_black=$(printf '\033[0;%s;40m' "${COLOR_GREEN_CODE}")
	            export GIT_STATUS_INFO="${initial_triangle_color}${triangle}${black_on_green} ${branch}${clean_indicators} ${green_on_black}${triangle}${reset}"
	        else
	        	local initial_triangle_color=$(printf '\033[%s;%sm' "${green_bg}" "${COLOR_BLUE_CODE}")
	            export GIT_STATUS_INFO="${initial_triangle_color}${triangle}${black_on_green} ${branch}${clean_indicators} ${green_fg}${triangle}${reset}"
	        fi
        else
            # Dirty
	        local yellow_fg=$(printf '\033[0;%sm' "${COLOR_YELLOW_CODE}")
	        local yellow_bg=$((COLOR_YELLOW_CODE + 10))
	        local black_on_yellow=$(printf '\033[0;%s;%sm' "${COLOR_BLACK_CODE}" "${yellow_bg}")
	        if [[ "$TERM_PROGRAM" == "Apple_Terminal" ]]; then
	        	local initial_triangle_color=$(printf '\033[%s;%sm' "${yellow_bg}" "${COLOR_BLACK_CODE}")
	        	local yellow_on_black=$(printf '\033[0;%s;40m' "${COLOR_YELLOW_CODE}")
	            export GIT_STATUS_INFO="${initial_triangle_color}${triangle}${black_on_yellow} ${branch}${status_indicators} ${yellow_on_black}${triangle}${reset}"
	        else
	        	local initial_triangle_color=$(printf '\033[%s;%sm' "${yellow_bg}" "${COLOR_BLUE_CODE}")
	            export GIT_STATUS_INFO="${initial_triangle_color}${triangle}${black_on_yellow} ${branch}${status_indicators} ${yellow_fg}${triangle}${reset}"
	        fi
        fi
	}

	function set_status_info() {
	    local last_exit=$?
        local reset=$(printf '\033[0m')
        local black_bg=$((COLOR_BLACK_CODE + 10))
	    if [[ $last_exit -eq 0 ]]; then
	        local magenta_on_black=$(printf '\033[%s;%sm' "${black_bg}" "${COLOR_MAGENTA_CODE}")
	        export STATUS_INFO="${magenta_on_black} ✔ ${reset}"
	    else
	        local bright_yellow_on_black=$(printf '\033[%s;%sm' "${black_bg}" "${COLOR_BRYELLOW_CODE}")
	        export STATUS_INFO="${bright_yellow_on_black} ${last_exit} ❌ ${reset}"
	    fi
	}

	function set_dir_stack_info() {
	    local depth=$(dirs -p | wc -l)
	    if [[ $depth -lt 2 ]]; then
	    	export DIR_STACK_INFO=""
	    	return
	    fi
	    # Calculate background colors
	    local magenta_bg=$((COLOR_MAGENTA_CODE + 10))
	    local white_bg=$((COLOR_WHITE_CODE + 10))
	    
	    # Construct ANSI codes with printf
	    local magenta_on_white=$(printf '\033[%s;%sm' "${white_bg}" "${COLOR_MAGENTA_CODE}")
	    local black_on_magenta=$(printf '\033[0;%s;%sm' "${COLOR_BLACK_CODE}" "${magenta_bg}")
	    local magenta_fg=$(printf '\033[0;%sm' "${COLOR_MAGENTA_CODE}")
	    local reset=$(printf '\033[0m')
	    local triangle=$(printf '\uE0B2')  # Left-pointing triangle
	    local depth_symbol=$(printf '\uF160')
	    
	    # Build the segment: triangle + content + end symbol
	    export DIR_STACK_INFO="${magenta_on_white}${triangle}${black_on_magenta} ${depth} ${black_on_magenta}${depth_symbol} ${reset}"
	}

	precmd() {
#		apply_scheme
		set_status_info
		set +F
		set_git_info
		set_dir_stack_info
	}
fi

do_timing "phase 11"

if [[ -d ~/.nvm ]]; then
	export NVM_DIR="$HOME/.nvm"
#	[[ -s "$NVM_DIR/nvm.sh" ]] && source "$NVM_DIR/nvm.sh" --no-use
	[[ -s "$NVM_DIR/nvm.sh" ]] && source "$NVM_DIR/nvm.sh"
	[[ "$ROPERDOT_CURRENT_SHELL" = bash && -s "$NVM_DIR/bash_completion" ]] && source "$NVM_DIR/bash_completion"
fi

# SDKMAN initialization
if [[ -d ~/.sdkman ]]; then
    export SDKMAN_DIR="$HOME/.sdkman"
    [[ -s "$SDKMAN_DIR/bin/sdkman-init.sh" ]] && source "$SDKMAN_DIR/bin/sdkman-init.sh"
fi

# Oracle Instant Client environment (find any installed version)
for oracle_dir in /opt/oracle/instantclient_*; do
    if [[ -d "$oracle_dir" ]]; then
        export ORACLE_HOME="$oracle_dir"
        export LD_LIBRARY_PATH="$ORACLE_HOME:$LD_LIBRARY_PATH"
        export DYLD_LIBRARY_PATH="$ORACLE_HOME:$DYLD_LIBRARY_PATH"
        export PATH="$ORACLE_HOME:$PATH"
        break
    fi
done

# .NET environment
if command -v dotnet >/dev/null 2>&1; then
    export PATH="$HOME/.dotnet/tools:$PATH"
fi

# Liquibase
[[ -d /opt/liquibase ]] && export PATH="$PATH:/opt/liquibase"

if [[ -f /etc/ssl/certs/ca-certificates.crt ]]; then
    export NODE_EXTRA_CA_CERTS=/etc/ssl/certs/ca-certificates.crt
    export REQUESTS_CA_BUNDLE=/etc/ssl/certs/ca-certificates.crt
    export SSL_CERT_FILE=/etc/ssl/certs/ca-certificates.crt
fi

do_timing

# Create symlinks in roperdot/extra-bin for scripts in roperdot/bin
#while IFS= read f; do
#	name="$(basename "$f")"
#	name="${name%%.p[ly]}"
#	[[ -e "${ROPERDOT_DIR}/extra-bin/$name" ]] || ln -s "$f" "${ROPERDOT_DIR}/extra-bin/$name"
#done < <(find "${ROPERDOT_DIR}/bin" -name "*.pl" -o -name "*.py")

# This should be done here instead of during installs so that executables like z will be defined
if [[ ! -f ~/roperdot-help.txt ]]; then
	echo "Building roperdot help file"
	. "${ROPERDOT_DIR}/bin/generate-help"
fi

if [[ -n "$ROPERDOT_DOT_IN_PATH" ]]; then
	export PATH=".:$PATH"
else
	export PATH
fi